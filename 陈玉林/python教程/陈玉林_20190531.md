[TOC]

## 输入输出

### 输出格式
str() 函数是用于返回人类可读的值的表示

repr() 是用于生成解释器可读的表示

**字符串的format方法**



**旧的字符串格式化方法**

% 操作符



### 读写文件

`open() `返回一个文件对象，最常用的有两个参数： open(filename, mode)

>   `'r'` ，表示文件只能读取(默认方式)
>
>   `'w'` 表示只能写入（已存在的同名文件会被删除）
>
>   `'a'` 表示打开文件以追加内容；任何写入的数据会自动添加到文件的末尾
>
>   `'r+'` 表示打开文件进行读写

>默认文件是以 *text mode* 打开的
>
>在mode 中追加的 `'b'` 则以 *binary mode* 打开文件：此时数据是以**字节**对象的形式进行读写的

>在文本模式下读取时，默认会把平台特定的行结束符 (Unix 上的 `\n`, Windows 上的 `\r\n`) 转换为 `\n`。在文本模式下写入时，默认会把出现的 `\n` 转换回平台特定的结束符。这样在幕后修改文件数据对文本文件来说没有问题，但是会破坏二进制数据例如 `JPEG` 或 `EXE` 文件中的数据。请一定要注意在读写此类文件时应使用二进制模式。

在处理文件对象时，最好使用 `with`关键字。 优点是当子句体结束后文件会正确关闭，即使在某个时刻引发了异常。 而且使用 `with` 相比等效的`try-finally` 代码块要简短得多

```python
with open('workfile') as f:
    data = f.read()
    
# 如果没有使用with关键字，则应该调用 f.close() 来关闭文件释放资源
# 如果你没有显式地关闭文件，Python的垃圾回收器最终将销毁该对象并为你关闭打开的文件，但这个文件可能会保持打开状态一段时间。另外一个风险是不同的Python实现会在不同的时间进行清理。
```

**文件对象的方法**

```python
# 读取
f.read()

# 读取一行
f.readline()

# 以列表的形式读取
f.readlines()

# 循环遍历文件对象
for line in f:
    print(line, end='')
    
# 把内容写入文件
f.write(string)
```

**使用json保存结构化数据**

```python
# 查看对象的json表示
json.dumps(x)

# 将对象序列化为text-file对象, sys.stdout为一个text-file对象
json.dump(x, sys.stdout)

# 解码对象
>>> new_x = json.load(sys.stdin)
"[1, \"hello\", \"world\"]"
>>> new_x
'[1, "hello", "world"]'
```

> tips: 这种方式只能用于处理序列，字典等简单结构，对于任意对象，还需要额外的处理工作