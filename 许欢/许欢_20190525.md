## 简单的文本处理

####   1.1tr命令

用来删除一段文本信息中的某些文字。或者将其进行转换。

格式： 

```
tr [option]...SET1 [SET2]
```

| `-d` | 删除和set1匹配的字符，注意不是全词匹配也不是按字符顺序匹配 |
| ---- | ---------------------------------------------------------- |
| `-s` | 去除set1指定的在输入文本中连续并重复的字符                 |

#### 1.2 col 命令

col 命令可以将`Tab`换成对等数量的空格键，或反转这个操作。

格式：

```
col [option]
```

| `-x` | 将`Tab`转换为空格             |
| ---- | ----------------------------- |
| `-h` | 将空格转换为`Tab`（默认选项） |

#### 1.3 join命令

用于将两个文件中包含相同内容的那一行合并在一起。 

格式：

```
join [option]... file1 file2
```

| `-t` | 指定分隔符，默认为空格                               |
| ---- | ---------------------------------------------------- |
| `-i` | 忽略大小写的差异                                     |
| `-1` | 指明第一个文件要用哪个字段来对比，默认对比第一个字段 |
| `-2` | 指明第二个文件要用哪个字段来对比，默认对比第一个字段 |

#### 1.4 paste命令

不对比数据的情况下，简单地将多个文件合并一起，以`Tab`隔开。

```
paste [option] file...
```

| `-d` | 指定合并的分隔符，默认为Tab  |
| ---- | ---------------------------- |
| `-s` | 不合并到一行，每个文件为一行 |

## 挑战:文本的处理与分析

data1 文件里记录是一些命令的操作记录，现在需要你从里面找出出现频率次数前3的命令并保存在 `/home/shiyanlou/result`。 

## Linux下软件安装

#### 2.1apt-get

| `install`      | 其后加上软件包名，用于安装一个软件包                         |
| -------------- | ------------------------------------------------------------ |
| `update`       | 从软件源镜像服务器上下载/更新用于更新本地软件源的软件包列表  |
| `upgrade`      | 升级本地可更新的全部软件包，但存在依赖问题时将不会升级，通常会在更新之前执行一次`update` |
| `dist-upgrade` | 解决依赖关系并升级(存在一定危险性)                           |
| `remove`       | 移除已安装的软件包，包括与被移除软件包有依赖关系的软件包，但不包含软件包的配置文件 |
| `autoremove`   | 移除之前被其他软件包依赖，但现在不再被使用的软件包           |
| `purge`        | 与remove相同，但会完全移除软件包，包含其配置文件             |
| `clean`        | 移除下载到本地的已经安装的软件包，默认保存在/var/cache/apt/archives/ |
| `autoclean`    | 移除已安装的软件的旧版本软件包                               |

下面是一些`apt-get`常用的参数：

| 参数                 | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| `-y`                 | 自动回应是否安装软件包的选项，在一些自动化安装脚本中使用这个参数将十分有用 |
| `-s`                 | 模拟安装                                                     |
| `-q`                 | 静默安装方式，指定多个`q`或者`-q=#`,#表示数字，用于设定静默级别，这在你不想要在安装软件包时屏幕输出过多时很有用 |
| `-f`                 | 修复损坏的依赖关系                                           |
| `-d`                 | 只下载不安装                                                 |
| `--reinstall`        | 重新安装已经安装但可能存在问题的软件包                       |
| `--install-suggests` | 同时安装APT给出的建议安装的软件包                            |

```
$ sudo apt-get --reinstall install w3m
```

更新：

```
# 更新软件源
$ sudo apt-get update
# 升级没有依赖问题的软件包
$ sudo apt-get upgrade
# 升级并解决依赖关系
$ sudo apt-get dist-upgrade
```

卸载（以w3m为例）：

```
sudo apt-get remove w3m
# 不保留配置文件的移除
$ sudo apt-get purge w3m
# 或者 sudo apt-get --purge remove
# 移除不再需要的被依赖的软件包
$ sudo apt-get autoremove
```

软件搜索：

```
sudo apt-cache search softname1 softname2 softname3……
```

#### 2.2 dpkg

以`deb`形式打包的软件包，就需要使用`dpkg`命令来安装。 

常用参数:

| `-i` | 安装指定deb包                                   |
| ---- | ----------------------------------------------- |
| `-R` | 后面加上目录名，用于安装该目录下的所有deb安装包 |
| `-r` | remove，移除某个已安装的软件包                  |
| `-I` | 显示`deb`包文件的信息                           |
| `-s` | 显示已安装软件的信息                            |
| `-S` | 搜索已安装的软件包                              |
| `-L` | 显示已安装软件包的目录信息                      |

`dpkg -L可以查看`deb`包目录信息 

```
$ sudo dpkg -L emacs24
```

## 作业：安装bb游戏

## LINUX进程

#### 3.1概念

> **程序**（procedure）：不太精确地说，程序就是执行一系列有逻辑、有顺序结构的指令，帮我们达成某个结果。 

> **进程**（process）：进程是程序在一个数据集合上的一次执行过程，在早期的UNIX、Linux 2.4及更早的版本中，它是系统进行资源分配和调度的独立基本单位。 
>
> **线程**（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率。 

进程有以下的特性：

- 动态性：进程的实质是一次程序执行的过程，有创建、撤销等状态的变化。而程序是一个静态的实体。
- 并发性：进程可以做到在一个时间段内，有多个程序在运行中。程序只是静态的实体，所以不存在并发性。
- 独立性：进程可以独立分配资源，独立接受调度，独立地运行。
- 异步性：进程以不可预知的速度向前推进。
- 结构性：进程拥有代码段、数据段、PCB（进程控制块，进程存在的唯一标志）。也正是因为有结构性，进程才可以做到独立地运行。

#### 3.2进程的衍生

> **fork()** 是一个系统调用（system call），它的主要作用就是为当前的进程创建一个新的进程，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如进程的执行代码段，内存信息，文件描述，寄存器状态等等 

> **exec()** 也是系统调用，作用是切换子进程中的执行程序也就是替换其从父进程复制过来的代码段与数据段 

#### 3.3进程组与 Sessions

进程组的 PGID 等同于进程组的第一个成员的 PID 

**靠 PGID（process group ID）来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。** 

进程一般通过使用 `getpgrp()` 系统调用来寻找其所在组的 PGID 。

每一个进程组都会在一个 Session 中，并且这个 Session 是唯一存在的， 

Session 中的每个进程都称为一个工作(job)。 Session 意义在于将多个 jobs 囊括在一个终端，并取其中的一个 job 作为前台，来直接接收该终端的输入输出以及终端信号。 其他 jobs 在后台运行。 

#### 3.4 工作管理

每个终端或者说 bash 只能管理当前终端中的 job，不能管理其他终端中的 job。 

一个进程在前台运作时我们可以用 `ctrl + c` 来终止它，但是若是在后台的话就不行了 。

通过 `&` 这个符号，让我们的命令在后台中运行 

```
ll &
```

通过 `ctrl + z` 使我们的当前工作停止并丢到后台中去

通过`jobs`来查看被停止并放置在后台的工作：

- 第一列显示的为被放置后台 job 的编号，

- 第二列的 `＋` 表示倒数第一个被放置后台的 job，同时也表示预设的工作，也就是若是有什么针对后台 job 的操作，首先对预设的 job，`-` 表示倒数第二（也就是在预设之前的一个）被放置后台的工作，倒数第三个（再之前的）以后都不会有这样的符号修饰。

- 第三列表示它们的状态，

- 最后一列表示该进程执行的命令 

通过`fg`命令将后台的工作拿到前台来 

```
fg %jobnumber
```

通过`bg`让其在后台运作 

```
bg %jobnumber
```

通过`kill`删除一个工作，或者重启等等 

<!--常用的信号值如下：-->

| -1   | 重新读取参数运行，类似与restart |
| ---- | ------------------------------- |
| -2   | 如同 ctrl+c 的操作退出          |
| -9   | 强制终止该任务                  |
| -15  | 正常的方式终止该任务            |

> 若是在使用kill＋信号值然后直接加 pid，你将会对 pid 对应的进程进行操作

> 若是在使用kill+信号值然后 `％jobnumber`，这时所操作的对象是 job，这个数字就是就当前 bash 中后台的运行的 job 的 ID

## 代码：https://github.com/inspurcloudgroup/icprd1/blob/master/%E8%AE%B8%E6%AC%A2/0525.docx

# 学习心得

今天重点学习了线程、进程、程序的概念，以及进程的衍生发展和相互间的关系，初步了解了工作管理的基础指令。但是具体的理解还不是很深入，仍需要在之后的学习与工作中进行加强 。
