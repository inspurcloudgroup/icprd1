# Linux进程之管理控制

## 进程的查看

- Linux 为我们提供了一些工具来查看进程的状态信息
- 可以通过 `top` 实时的查看进程的状态，以及系统的一些信息（如 CPU、内存信息等）
- 可以通过 `ps` 来静态查看当前的进程信息
- 可以使用 `pstree` 来查看当前活跃进程的树形结构

### top工具的使用

- `top` 工具是我们常用的一个查看工具，能实时的查看我们系统的一些关键信息的变化

- top 是一个在前台执行的程序，所以执行后便进入一个交互界面，正是因为交互界面我们才可以实时的获取到系统与进程的信息

- 在交互界面中我们可以通过一些指令来操作和筛选

  ![01](C:\Users\tanghang\Desktop\jobs\培训\岗前培训\pic\20190604\01.png)

- 交互界面中显示的信息

  - top显示的第一排

    | 内容                         | 解释                                |
    | ---------------------------- | ----------------------------------- |
    | top                          | 表示当前程序的名称                  |
    | 16:17:07                     | 表示当前的系统的时间                |
    | up 347 days,16:04            | 表示该机器已经启动了多长时间        |
    | 1 user                       | 表示当前系统中只有一个用户          |
    | load average: 0.96,0.71,0.61 | 分别对应1、5、15分钟内cpu的平均负载 |

  - load average

    - 在 wikipedia 中的解释是 the system load is a measure of the amount of work that a computer system is doing 也就是对当前 CPU 工作量的度量，具体来说也就是指运行队列的平均长度，也就是等待 CPU 的平均进程数相关的一个计算值

    - 假设我们的系统是单 CPU、单内核的，把它比喻成是一条单向的桥，把CPU任务比作汽车

      - load = 0 的时候意味着这个桥上并没有车，cpu 没有任何任务；
      - load < 1 的时候意味着桥上的车并不多，一切都还是很流畅的，cpu 的任务并不多，资源还很充足；
      - load = 1 的时候就意味着桥已经被车给占满了，没有一点空隙，cpu 的已经在全力工作了，所有的资源都被用完了，当然还好，这还在能力范围之内，只是有点慢而已；
      - load > 1 的时候就意味着不仅仅是桥上已经被车占满了，就连桥外都被占满了，cpu 已经在全力工作，系统资源的用完了，但是还是有大量的进程在请求，在等待。若是这个值大于２、大于３，表示进程请求超过 CPU 工作能力的 2 到 ３ 倍。而若是这个值 > 5 说明系统已经在超负荷运作了。

    - 如果是多核cpu需要将得到的这个值除以我们的核数来看

    - 可以通过以下的命令来查看 CPU 的个数与核心数

      ```
      #查看物理CPU的个数
      #cat /proc/cpuinfo |grep "physical id"|sort |uniq|wc -l
      
      #每个cpu的核心数
      cat /proc/cpuinfo |grep "physical id"|grep "0"|wc -l
      ```

  - top显示的第二行数据：进程情况统计

    | 内容            | 解释                |
    | --------------- | ------------------- |
    | Tasks: 28 total | 进程总数            |
    | 1 running       | 1个正在运行的进程数 |
    | 27 sleeping     | 25个睡眠的进程数    |
    | 0 stopped       | 没有停止的进程数    |
    | 0 zombie        | 没有僵尸进程数      |

  - top显示的第三行数据：cpu使用情况统计 

    | 内容            | 解释                                                         |
    | --------------- | ------------------------------------------------------------ |
    | Cpu(s): 15.2%us | 用户空间进程占用CPU百分比                                    |
    | 1.8% sy         | 内核空间运行占用CPU百分比                                    |
    | 0.0%ni          | 用户进程空间内改变过优先级的进程占用CPU百分比                |
    | 81.3%id         | 空闲CPU百分比                                                |
    | 0.9%wa          | 等待输入输出的CPU时间百分比                                  |
    | 0.0%hi          | 硬中断(Hardware IRQ)占用CPU的百分比                          |
    | 0.8%si          | 软中断(Software IRQ)占用CPU的百分比                          |
    | 0.0%st          | (Steal time) 是 hypervisor 等虚拟服务中，虚拟 CPU 等待实际 CPU 的时间的百分比 |

  - CPU 利用率是对一个时间段内 CPU 使用状况的统计，通过这个指标可以看出在某一个时间段内 CPU 被占用的情况，而 Load Average 是 CPU 的 Load，它所包含的信息不是 CPU 的使用率状况，而是在一段时间内 CPU 正在处理以及等待 CPU 处理的进程数情况统计信息，这两个指标并不一样

  - top显示的第四行数据：内存使用情况统计

    | 内容             | 解释                 |
    | ---------------- | -------------------- |
    | 16432616 total   | 物理内存总量         |
    | 4221860 used     | 使用的物理内存总量   |
    | 549292 free      | 空闲内存总量         |
    | 11661464 buffers | 用作内核缓存的内存量 |

  - top显示的第5行数据：交换区使用情况统计

    | 内容   | 解释                                                         |
    | ------ | ------------------------------------------------------------ |
    | total  | 交换区总量                                                   |
    | used   | 使用的交换区总量                                             |
    | free   | 空闲交换区总量                                               |
    | cached | 缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖 |

  - 再下面就是进程的情况

    | 列名    | 解释                                         |
    | ------- | -------------------------------------------- |
    | PID     | 进程id                                       |
    | USER    | 该进程的所属用户                             |
    | PR      | 该进程执行的优先级 priority 值               |
    | NI      | 该进程的 nice 值                             |
    | VIRT    | 该进程任务所使用的虚拟内存的总数             |
    | RES     | 该进程所使用的物理内存数，也称之为驻留内存数 |
    | SHR     | 该进程共享内存的大小                         |
    | S       | 该进程进程的状态: S=sleep R=running Z=zombie |
    | %CPU    | 该进程CPU的利用率                            |
    | %MEM    | 该进程内存的利用率                           |
    | TIME+   | 该进程活跃的总时间                           |
    | COMMAND | 该进程运行的名字                             |

    - NICE 值叫做静态优先级，是用户空间的一个优先级值，其取值范围是-20至19。这个值越小，表示进程”优先级”越高，而值越大“优先级”越低。nice值中的 -20 到 19，中 -20 优先级最高， 0 是默认的值，而 19 优先级最低

    - PR 值表示 Priority 值叫动态优先级，是进程在内核中实际的优先级值，进程优先级的取值范围是通过一个宏定义的，这个宏的名称是`MAX_PRIO`，它的值为 140。Linux 实际上实现了 140 个优先级范围，取值范围是从 0-139，这个值越小，优先级越高。而这其中的 0 - 99 是实时进程的值，而 100 - 139 是给用户的。
    - 其中 PR 中的 100 to 139 值部分有这么一个对应 `PR = 20 + (-20 to +19)`，这里的 -20 to +19 便是nice值，所以说两个虽然都是优先级，而且有千丝万缕的关系，但是他们的值，他们的作用范围并不相同
    - VIRT表示任务所使用的虚拟内存的总数，其中包含所有的代码，数据，共享库和被换出 swap空间的页面等所占据空间的总数

- 与top交互界面交互的常用命令

  | 常用交互命令 | 解释                                                         |
  | ------------ | ------------------------------------------------------------ |
  | q            | 退出程序                                                     |
  | I            | 切换显示平均负载和启动时间的信息                             |
  | P            | 根据CPU使用百分比大小进行排序                                |
  | M            | 根据驻留内存大小进行排序                                     |
  | i            | 忽略闲置和僵死的进程，这是一个开关式命令                     |
  | k            | 终止一个进程，系统提示输入 PID 及发送的信号值。一般终止进程用 15 信号，不能正常结束则使用 9 信号。安全模式下该命令被屏蔽。 |

### ps工具的使用

- 常用命令

  ```
  ps aux
  
  ps axjf
  ```

- ps返回结果的各个字段的含义

  | 内容      | 解释                                                         |
  | --------- | ------------------------------------------------------------ |
  | F         | 进程的标志（process flags），当 flags 值为 1 则表示此子程序只是 fork 但没有执行 exec，为 4 表示此程序使用超级管理员 root 权限 |
  | USER      | 进程的拥有用户                                               |
  | PID       | 进程的 ID                                                    |
  | PPID      | 其父进程的 PID                                               |
  | SID       | session 的 ID                                                |
  | TPGID     | 前台进程组的 ID                                              |
  | %CPU      | 进程占用的 CPU 百分比                                        |
  | %MEM      | 占用内存的百分比                                             |
  | NI        | 进程的 NICE 值                                               |
  | VSZ       | 进程使用虚拟内存大小                                         |
  | RSS       | 驻留内存中页的大小                                           |
  | TTY       | 终端 ID                                                      |
  | S or STAT | 进程状态                                                     |
  | WCHAN     | 正在等待的进程资源                                           |
  | START     | 启动进程的时间                                               |
  | TIME      | 进程消耗CPU的时间                                            |
  | COMMAND   | 命令的名称和参数                                             |
  - TPGID栏写着-1的都是没有控制终端的进程，也就是守护进程

  - STAT表示进程的状态，而进程的状态有很多，如下表所示

    | 状态 | 解释                               |
    | ---- | ---------------------------------- |
    | R    | Running.运行中                     |
    | S    | Interruptible Sleep.等待调用       |
    | D    | Uninterruptible Sleep.不可中断睡眠 |
    | T    | Stoped.暂停或者跟踪状态            |
    | X    | Dead.即将被撤销                    |
    | Z    | Zombie.僵尸进程                    |
    | W    | Paging.内存交换                    |
    | N    | 优先级低的进程                     |
    | <    | 优先级高的进程                     |
    | s    | 进程的领导者                       |
    | L    | 锁定状态                           |
    | l    | 多线程状态                         |
    | +    | 前台进程                           |

    - 其中的 D 是不能被中断睡眠的状态，处在这种状态的进程不接受外来的任何 signal，所以无法使用 kill 命令杀掉处于D状态的进程，无论是 `kill`，`kill -9` 还是 `kill -15`，一般处于这种状态可能是进程 I/O 的时候出问题了

- ps命令的各种参数

  - 使用 `-l` 参数可以显示自己这次登陆的 bash 相关的进程信息罗列出来

    ```
    ps -l
    ```

  - 罗列出所有的进程信息

    ```
    ps aux
    ```

  - 若是查找其中的某个进程的话，我们还可以配合着 grep 和正则表达式一起使用

    ```
    ps aux | grep zsh
    ```

  - 还可以查看时，将连同部分的进程呈树状显示出来

    ```
    ps axjf
    ```

  - 可以自定义我们所需要的参数显示，将想要的信息放在一起

    ```
    ps -afxo user,ppid,pid,pgid,command
    ```

### pstree工具的使用

- 通过 pstree 可以很直接的看到相同的进程数量，还可以看到所有进程之间的相关性

  ```
  pstree
  
  pstree -up
  #参数选择：
  #-A  ：各程序树之间以 ASCII 字元來連接；
  #-p  ：同时列出每个 process 的 PID；
  #-u  ：同时列出每个 process 的所屬账户名称。
  ```

## 进程的管理

### kill命令的掌握

- 当一个进程结束的时候或者要异常结束的时候，会向其父进程返回一个或者接收一个 SIGHUP 信号而做出的结束进程或者其他的操作

- SIGHUP信号不仅可以由系统发送，我们可以使用 kill 来发送这个信号来操作进程的结束或者重启等等

- 用 kill 来操作不属于 job 范畴的进程，直接对 pid 下手

  ```
  #首先我们使用图形界面打开了 gedit、gvim，用 ps 可以查看到
  ps aux
  
  #使用9这个信号强制结束 gedit 进程
  kill -9 1608
  
  #我们再查找这个进程的时候就找不到了
  ps aux | grep gedit 
  ```

### 进程的执行顺序

- 大部分的进程都是处于休眠的状态，如果这些进程都被唤醒，就是靠该进程的优先级值来判定进程调度的优先级

-  nice 的值可以通过 nice 命令来修改

  ```
  #打开一个程序放在后台，或者用图形界面打开
  nice -n -5 vim &
  
  #用 ps 查看其优先级
  ps -afxo user,ppid,pid,stat,pri,ni,time,command | grep vim
  ```

  -  nice 值可以调整的范围是 -20 ~ 19
  - root 有着至高无上的权力，既可以调整自己的进程也可以调整其他用户的程序，并且是所有的值都可以用
  - 普通用户只可以调制属于自己的进程，并且其使用的范围只能是 0 ~ 19，因为系统为了避免一般用户抢占系统资源而设置的一个限制

- 我们还可以用`renice`来修改已经存在的进程的优先级

  ```
  renice -5 pid
  ```

  