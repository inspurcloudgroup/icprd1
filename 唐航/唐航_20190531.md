# 数据流重定向

### 简单的重定向

- Linux默认提供了三个设备

  | 文件描述符 | 设备文件      | 说明     |
  | ---------- | ------------- | -------- |
  | `0`        | `/dev/stdin`  | 标准输入 |
  | `1`        | `/dev/stdout` | 标准输出 |
  | `2`        | `/dev/stderr` | 标准错误 |

- 文件描述符
  - 在形式上是一个非负整数
  - 是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表
  - 当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符
  - 在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开
  - 文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统
  
- 文件描述符的使用
  - 默认使用终端的标准输入作为命令的输入
  - 默认使用终端的标准输出作为命令的输出
  - 示例
    - 将cat的连续输出（heredoc方式）重定向到一个文件
    
      ```
      mkdir Documents
      cat > Documents/test.c <<EOF
      #include <stdio.h>
      
      int main()
      {
          printf("hello world\n");
          return 0;
      }
      
      EOF
      ```
    
    - 将一个文件作为命令的输入，标准输出作为命令的输出
    
      ```
      cat Documents/test.c
      ```
    
    - 将echo命令通过管道传过来的数据作为cat命令的输入，将标准输出作为命令的输出
    
      ```
      echo 'hi' | cat
      ```
    
    - 将echo命令的输出从默认的标准输出重定向到一个普通文件
    
      ```
      echo 'hello shiyanlou' > redirect
      cat redirect
      ```
  
- 管道与重定向

  - 管道默认是连接前一个命令的输出到下一个命令的输入
  - 重定向通常是需要一个文件来建立两个命令的连接

### 标准错误重定向

- 标准输出和标准错误都被指向伪终端的屏幕显示

- 我们经常看到的一个命令的输出通常是同时包含了标准输出和标准错误的结果的

- 标准输出和标准错误虽然都指向伪终端，但两者并不一样

- 示例

  ```
  # 使用cat 命令同时读取两个文件，其中一个存在，另一个不存在
  cat Documents/test.c hello.c
  # 你可以看到除了正确输出了前一个文件的内容，还在末尾出现了一条错误信息
  # 下面我们将输出重定向到一个文件
  cat Documents/test.c hello.c > somefile
  #结果只将第一个文件重定向到了somefile，错误信息输出到了标准输出
  ```

- 使用文件描述符

  ```
  # 将标准错误重定向到标准输出，再将标准输出重定向到文件，注意要将重定向到文件写到前面
  cat Documents/test.c hello.c >somefile  2>&1
  # 或者只用bash提供的特殊的重定向符号"&"将标准错误和标准输出同时重定向到文件
  cat Documents/test.c hello.c &>somefilehell
  ```
  - 注意应该在输出重定向文件描述符前加上&,否则shell会当做重定向到一个文件名为1的文件中

### 使用tee命令同时重定向到多个文件

- 可能还有这样的需求，除了需要将输出重定向到文件,也需要将信息打印在终端。那么你可以使用`tee`命令来实现

  ```
  echo 'hello shiyanlou' | tee hello
  ```

### 永久重定向

- 可以使用`exec`命令实现“永久”重定向

- `exec`命令的作用是使用指定的命令替换当前的Shell

- 示例

  ```
  # 先开启一个子 Shell
  zsh
  # 使用exec替换当前进程的重定向，将标准输出重定向到一个文件
  exec 1>somefile
  # 后面你执行的命令的输出都将被重定向到文件中,直到你退出当前子shell，或取消exec的重定向（后面将告诉你怎么做）
  ls
  exit
  cat somefile
  ```

### 创建输出文件描述符

- 在 Shell 中有9个文件描述符

- 可以使用3-8的文件描述符，只是它们默认没有打开而已

- 可以使用下面命令查看当前 Shell 进程中打开的文件描述符

  ```
  cd /dev/fd/;ls -Al
  ```

- 同样使用`exec`命令可以创建新的文件描述符

  ```
  zsh
  exec 3>somefile
  # 先进入目录，再查看，否则你可能不能得到正确的结果，然后再回到上一次的目录
  cd /dev/fd/;ls -Al;cd -
  # 注意下面的命令>与&之间不应该有空格，如果有空格则会出错
  echo "this is test" >&3
  cat somefile
  exit
  ```

### 关闭文件描述符

- 上面打开的3号文件描述符，可以使用如下操作将它关闭

  ```
  exec 3>&-
  cd /dev/fd;ls -Al;cd -
  ```

### 完全屏蔽命令的输出

- 在 Linux 中有一个被称为“黑洞”的设备文件,所有导入它的数据都将被“吞噬”
- 在类 UNIX 系统中，`/dev/null`，或称空设备，是一个特殊的设备文件
- `/dev/null`通常被用于丢弃不需要的输出流，或作为用于输入流的空文件，这些操作通常由重定向完成
- 读取`/dev/null`则会立即得到一个`EOF`

- 可以利用`/dev/null`屏蔽命令的输出

  ```
  cat Documents/test.c nefile 1>/dev/null 2>&1
  ```

### 使用`xargs`分割参数列表

- `xargs`是一条`UNIX`和类`UNIX`操作系统的常用命令
- `xargs`的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题

- 示例

  ```
  cut -d: -f1 < /etc/passwd | sort | xargs echo
  ```
  - 这个命令用于将`/etc/passwd`文件按`:`分割取第一个字段排序后，使用`echo`命令生成一个列表

  - 如果不加`xargs`，这个命令没有输出