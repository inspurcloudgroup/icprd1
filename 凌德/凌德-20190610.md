# Java面向对象
面向对象其实就是指我们从这个对象的整体出发去看它，它由哪些部件组成，它可以做到哪些事情。<br>
### 1.类
类是相同或相似对象的一种抽象，是对象的一个模板，它描述一类对象的行为和状态,是具有相同属性和方法（行为）的对象的集合。<br>
属性是对象具有的特征。每个对象的每个属性都拥有特定值。<br>
定义类名，用于区分不同的类；public class 后面跟的就是类名。class是声明类的关键字，类名后面跟上大括号，大括号里面就是类的一些信息。public为权限修饰符。<br><br>
![text](https://github.com/asdLingDe/hellow-world/blob/master/%E5%87%8C%E5%BE%B7/70.png?raw=true)<br><br>
一个类可以包含:局部变量、成员变量、类变量.<br>
### 2.对象
创建对象的语法:类名 对象名 = new 类名();<br><br>
![text](https://github.com/asdLingDe/hellow-world/blob/master/%E5%87%8C%E5%BE%B7/71.png?raw=true)<br><br>
使用对象即对属性和方法进行操作和调用：<br>
对象名.属性//引用对象属性；<br>
对象名.方法//引用对象方法；<br>
局部变量的作用域仅限于定义它的方法内；成员变量的作用域在整个类内部都是可见的；<br>
在相同的方法中，不能有同名的局部变量；在不同的方法中，可以有同名的局部变量；<br>
成员变量和局部变量同名时，局部变量具有更高的优先级。<br>
### 3.构造方法
。每个类都有构造方法，在创建该类的对象的时候他们将被调用，创建一个对象的时候，至少调用一个构造方法。<br>
构造方法的名称与类名相同，且没有返回值：<br><br>
public 构造方法名(){<br>
//初始化代码<br>
}<br>
### 4.引用与对象实例
Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。<br>
final关键字可以修饰类、方法、属性和变量：<br><br>
final 修饰类，则该类不允许被继承，为最终类；<br>
final 修饰方法，则该方法不允许被覆盖（重写）；<br>
final 修饰属性：则该类的属性不会进行隐式的初始化（类的初始化属性必须有值）或在构造方法中赋值（但只能选其一）；<br>
final 修饰变量，则该变量的值只能赋一次值，即常量。<br>
代码中经常用到private和public修饰符，权限修饰符可以用来修饰属性和方法的访问范围。<br>
protected修饰的属性或者方法，对同封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别一包内的类和所有子类可见。public修饰的属性或者方法，对所有类可见。<br>
封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别；<br>
这样做r让人只能通过规定的方法访问数据，可以隐藏类的实例细节，方便修改和实现。<br><br>
![text](https://github.com/asdLingDe/hellow-world/blob/master/%E5%87%8C%E5%BE%B7/72.png?raw=true)<br><br>
this关键字代表当前对象。使用this.属性操作当前对象的属性，this.方法调用当前对象的方法。<br>
用private修饰的属性，必须定义 getter 和 setter 方法才可以访问到。<br>
继承可以看成是类与类之间的衍生关系：<br>
class 子类 extends 父类<br><br>
![text](https://github.com/asdLingDe/hellow-world/blob/master/%E5%87%8C%E5%BE%B7/73.png?raw=true)<br><br>
继承的特点：<br><br>
子类拥有父类除 private 以外的所有属性和方法；<br>
子类可以拥有自己的属性和方法；<br>
子类可以重写实现父类的方法；<br>
Java 中的继承是单继承，一个类只有一个父类。<br>
super关键字在子类内部使用，代表父类对象：<br>
访问父类的属性： super.属性名<br>
访问父类的方法： super.bark()<br>
### 5.方法重载与重写
方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。方法重载一般用于创建一组任务相似但是参数不同的方法。<br><br>
![text](https://github.com/asdLingDe/hellow-world/blob/master/%E5%87%8C%E5%BE%B7/74.png?raw=true)<br><br>
方法重载的规则：<br><br>
方法中的参数列表必须不同；<br>
重载的方法中允许抛出不同的异常；<br>
可以有不同的返回值类型，但是参数列表必须不同；<br>
可以有不同的访问修饰符。<br>
方法重写时要注意，重写的方法一定要与原父类的方法语法保持一致。<br><br>
![text](https://github.com/asdLingDe/hellow-world/blob/master/%E5%87%8C%E5%BE%B7/75.png?raw=true)<br><br>
多态是指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。<br>
一个指向子类对象的父类引用类型除了能够引用父类中定义的所有属性和方法外，还可以使用子类强大的功能。但是对于只存在于子类的方法和属性就不能获取。<br><br>
![text](https://github.com/asdLingDe/hellow-world/blob/master/%E5%87%8C%E5%BE%B7/76.png?raw=true)<br><br>
Java 实现多态有三个必要条件：继承、重写和向上转型（即父类引用指向子类对象）。<br>
Java 中多态的实现方式：继承父类进行方法重写，抽象类和抽象方法，接口实现。<br>
在定义类时，前面加上abstract关键字修饰的类叫抽象类。 抽象类中有抽象方法，这种方法是不完整的，仅有声明而没有方法体。<br>
抽象类用代码实现的规则：<br><br>
用 abstract 修饰符定义抽象类；<br>
用 abstract 修饰符定义抽象方法，只用声明，不需要实现；<br>
包含抽象方法的类就是抽象类；<br>
抽象类中可以包含普通的方法，也可以没有抽象方法；<br>
抽象类的对象不能直接创建，通常是定义引用变量指向子类对象。<br><br>
![text](https://github.com/asdLingDe/hellow-world/blob/master/%E5%87%8C%E5%BE%B7/77.png?raw=true)<br><br>
接口用于描述类所具有的功能，而不提供功能的实现，功能的实现需要写在实现接口的类中，并且该类必须实现接口中所有的未实现方法。<br><br>
![text](https://github.com/asdLingDe/hellow-world/blob/master/%E5%87%8C%E5%BE%B7/78.png?raw=true)<br><br>
将一个类的定义放在另一个类的定义内部，这就是内部类。而包含内部类的类被称为外部类。<br>
内部类的主要作用：<br><br>
内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类；<br>
内部类的方法可以直接访问外部类的所有数据，包括私有的数据；<br>
内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便；<br>
内部类允许继承多个非接口类型。<br><br>
![text](https://github.com/asdLingDe/hellow-world/blob/master/%E5%87%8C%E5%BE%B7/79.png?raw=true)<br><br>
静态内部类通常被称为嵌套类。<br>
![text](https://github.com/asdLingDe/hellow-world/blob/master/%E5%87%8C%E5%BE%B7/80.jpg?raw=true)<br><br>
静态内部类是 static 修饰的内部类，它的特点是：<br><br>
静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问；<br>
如果外部类的静态成员与内部类的成员名称相同，可通过类名.静态成员访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过成员名直接调用外部类的静态成员；<br>
创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名= new 内部类();<br>
局部内部类，是指内部类定义在方法和作用域内。<br><br>
![text](https://github.com/asdLingDe/hellow-world/blob/master/%E5%87%8C%E5%BE%B7/81.png?raw=true)<br>
局部内部类只在该方法或条件的作用域内才能使用，退出这些作用域后无法引用的。<br>
匿名内部类是没有名字的内部类。正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写。但使用匿名内部类时必须继承一个父类或实现一个接口。<br><br>
![text](https://github.com/asdLingDe/hellow-world/blob/master/%E5%87%8C%E5%BE%B7/82.png?raw=true)<br><br>
为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。<br>
包的作用：<br><br>
把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用；<br>
包采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别；<br>
包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。<br>
