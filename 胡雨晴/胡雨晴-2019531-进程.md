# 一．软件管理

## 1，安装软件包

我们安装一个软件，名字叫做 w3m(w3m是一个命令行的简易网页浏览器)，那么输入如下命令：

$ sudo apt-get install w3m

可以使用如下方式重新安装：

```
$ sudo apt-get --reinstall install w3m
```

如何在不知道软件包完整名的时候进行安装。通常我们是使用`Tab`键补全软件包名

## 2．Apt-get 

apt-get 是用于处理 apt包的公用程序集，我们可以用它来在线安装、卸载和升级软件包等，下面列出一些apt-get包含的常用的一些工具：

| **工具**     | **说明**                                                     |
| ------------ | ------------------------------------------------------------ |
| install      | 其后加上软件包名，用于安装一个软件包                         |
| update       | 从软件源镜像服务器上下载/更新用于更新本地软件源的软件包列表  |
| upgrade      | 升级本地可更新的全部软件包，但存在依赖问题时将不会升级，通常会在更新之前执行一次update |
| dist-upgrade | 解决依赖关系并升级(存在一定危险性)                           |
| remove       | 移除已安装的软件包，包括与被移除软件包有依赖关系的软件包，但不包含软件包的配置文件 |
| autoremove   | 移除之前被其他软件包依赖，但现在不再被使用的软件包           |
| purge        | 与remove相同，但会完全移除软件包，包含其配置文件             |
| clean        | 移除下载到本地的已经安装的软件包，默认保存在/var/cache/apt/archives/ |
| autoclean    | 移除已安装的软件的旧版本软件包                               |

下面是一些apt-get常用的参数：

| **参数**           | **说明**                                                     |
| ------------------ | ------------------------------------------------------------ |
| -y                 | 自动回应是否安装软件包的选项，在一些自动化安装脚本中使用这个参数将十分有用 |
| -s                 | 模拟安装                                                     |
| -q                 | 静默安装方式，指定多个q或者-q=#,#表示数字，用于设定静默级别，这在你不想要在安装软件包时屏幕输出过多时很有用 |
| -f                 | 修复损坏的依赖关系                                           |
| -d                 | 只下载不安装                                                 |
| --reinstall        | 重新安装已经安装但可能存在问题的软件包                       |
| --install-suggests | 同时安装APT给出的建议安装的软件包                            |

## 3.软件升级

\# 更新软件源

$ sudo apt-get update

\# 升级没有依赖问题的软件包

$ sudo apt-get upgrade

\# 升级并解决依赖关系

$ sudo apt-get dist-upgrade

## 4.卸载软件

Sudo apt-get remove w3m

或者

不保留配置文件的移除

$ sudo apt-get purge w3m

\# 或者 sudo apt-get --purge remove

\# 移除不再需要的被依赖的软件包

$ sudo apt-get autoremove

## 5.软件搜索

当自己刚知道了一个软件，想下载使用，需要确认软件仓库里面有没有，就需要用到搜索功能了，命令如下：

```
sudo apt-cache search softname1 softname2 softname3……
```

## `6.``使用dpkg从本地磁盘安装deb软件包`

我们经常可以在网络上见到以deb形式打包的软件包，就需要使用dpkg命令来安装。

dpkg常用参数介绍：

| **参数** | **说明**                                        |
| -------- | ----------------------------------------------- |
| -i       | 安装指定deb包                                   |
| -R       | 后面加上目录名，用于安装该目录下的所有deb安装包 |
| -r       | remove，移除某个已安装的软件包                  |
| -I       | 显示deb包文件的信息                             |
| -s       | 显示已安装软件的信息                            |
| -S       | 搜索已安装的软件包                              |
| -L       | 显示已安装软件包的目录信息                      |

我们先使用`apt-get`加上`-d`参数只下载不安装（sudo apt-get –d install emcas），下载emacs编辑器的deb包，下载完成后，我们可以查看/var/cache/apt/archives/目录下的内容

然后我们将第一个`deb`拷贝到 /home/shiyanlou 目录下，并使用`dpkg`安装

```
$ cp /var/cache/apt/archives/emacs24_24.5+1-6ubuntu1.1_amd64.deb ~
# 安装之前参看deb包的信息
$ sudo dpkg -I emacs24_24.5+1-6ubuntu1.1_amd64.deb
```

这个包还额外依赖了一些软件包，这意味着，如果主机目前没有这些被依赖的软件包，直接使用dpkg安装可能会存在一些问题，因为`dpkg`并不能为你解决依赖关系。要用到`apt-get`了，使用它的`-f`参数了，修复依赖关系的安装

```
$ sudo apt-get update
$ sudo apt-get -f install
查看已安装软件包的安装目录
Sudo dpkg –L emacs24
```

## 7.轻松一下

sudo apt-get update

$ sudo apt-get install bb

$ /usr/games/bb

# 二．进程管理

## 1.进程的查看（top）

top 显示的第一排，

| **内容**                       | **解释**                            |
| ------------------------------ | ----------------------------------- |
| top                            | 表示当前程序的名称                  |
| 11:05:18                       | 表示当前的系统的时间                |
| up 8 days,17:12                | 表示该机器已经启动了多长时间        |
| 1 user                         | 表示当前系统中只有一个用户          |
| load average:   0.29,0.20,0.25 | 分别对应1、5、15分钟内cpu的平均负载 |

假设我们的系统是单 CPU、单内核的，把它比喻成是一条单向的桥，把CPU任务比作汽车。

- load = 0 的时候意味着这个桥上并没有车，cpu 没有任何任务；
- load < 1 的时候意味着桥上的车并不多，一切都还是很流畅的，cpu 的任务并不多，资源还很充足；
- load = 1 的时候就意味着桥已经被车给占满了，没有一点空隙，cpu 的已经在全力工作了，所有的资源都被用完了，当然还好，这还在能力范围之内，只是有点慢而已；
- load > 1 的时候就意味着不仅仅是桥上已经被车占满了，就连桥外都被占满了，cpu 已经在全力工作，系统资源的用完了，但是还是有大量的进程在请求，在等待。若是这个值大于２、大于３，表示进程请求超过 CPU 工作能力的 2 到 ３ 倍。而若是这个值 > 5 说明系统已经在超负荷运作了

\#查看物理CPU的个数

\#cat /proc/cpuinfo |grep "physical id"|sort |uniq|wc -l

 

\#每个cpu的核心数

cat /proc/cpuinfo |grep "physical id"|grep "0"|wc -l

 

top 的第二行数据，基本上第二行是进程的一个情况统计

| **内容**        | **解释**            |
| --------------- | ------------------- |
| Tasks: 26 total | 进程总数            |
| 1 running       | 1个正在运行的进程数 |
| 25 sleeping     | 25个睡眠的进程数    |
| 0 stopped       | 没有停止的进程数    |
| 0 zombie        | 没有僵尸进程数      |

来看 top 的第三行数据，这一行基本上是 CPU 的一个使用情况的统计了

| **内容**       | **解释**                                                     |
| -------------- | ------------------------------------------------------------ |
| Cpu(s): 1.0%us | 用户空间进程占用CPU百分比                                    |
| 1.0% sy        | 内核空间运行占用CPU百分比                                    |
| 0.0%ni         | 用户进程空间内改变过优先级的进程占用CPU百分比                |
| 97.9%id        | 空闲CPU百分比                                                |
| 0.0%wa         | 等待输入输出的CPU时间百分比                                  |
| 0.1%hi         | 硬中断(Hardware IRQ)占用CPU的百分比                          |
| 0.0%si         | 软中断(Software IRQ)占用CPU的百分比                          |
| 0.0%st         | (Steal time) 是 hypervisor 等虚拟服务中，虚拟 CPU 等待实际 CPU 的时间的百分比 |

top 的第四行数据，这一行基本上是内存的一个使用情况的统计了：

| **内容**       | **解释**             |
| -------------- | -------------------- |
| 8176740 total  | 物理内存总量         |
| 8032104 used   | 使用的物理内存总量   |
| 144636 free    | 空闲内存总量         |
| 313088 buffers | 用作内核缓存的内存量 |

top 的第五行数据，这一行基本上是交换区的一个使用情况的统计了

| **内容** | **解释**                                                     |
| -------- | ------------------------------------------------------------ |
| total    | 交换区总量                                                   |
| used     | 使用的交换区总量                                             |
| free     | 空闲交换区总量                                               |
| cached   | 缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖 |

再下面就是进程的一个情况了

| **列名** | **解释**                                     |
| -------- | -------------------------------------------- |
| PID      | 进程id                                       |
| USER     | 该进程的所属用户                             |
| PR       | 该进程执行的优先级 priority 值               |
| NI       | 该进程的 nice 值                             |
| VIRT     | 该进程任务所使用的虚拟内存的总数             |
| RES      | 该进程所使用的物理内存数，也称之为驻留内存数 |
| SHR      | 该进程共享内存的大小                         |
| S        | 该进程进程的状态: S=sleep R=running Z=zombie |
| %CPU     | 该进程CPU的利用率                            |
| %MEM     | 该进程内存的利用率                           |
| TIME+    | 该进程活跃的总时间                           |
| COMMAND  | 该进程运行的名字                             |

top 是一个前台程序，所以是一个可以交互的

| **常用交互命令** | **解释**                                                     |
| ---------------- | ------------------------------------------------------------ |
| q                | 退出程序                                                     |
| I                | 切换显示平均负载和启动时间的信息                             |
| P                | 根据CPU使用百分比大小进行排序                                |
| M                | 根据驻留内存大小进行排序                                     |
| i                | 忽略闲置和僵死的进程，这是一个开关式命令                     |
| k                | 终止一个进程，系统提示输入 PID 及发送的信号值。一般终止进程用 15 信号，不能正常结束则使用 9 信号。安全模式下该命令被屏蔽。 |

## 2.ps工具的使用

Ps aux

Ps axjf

使用 `-l` 参数可以显示自己这次登陆的 bash 相关的进程信息罗列出来(ps –l)

## 3.pstree工具的使用

pstree -up

 

\#参数选择：

\#-A  ：各程序树之间以 ASCII 字元來連接；

\#-p  ：同时列出每个 process 的 PID；

\#-u  ：同时列出每个 process 的所屬账户名称。

## 4.kill命令的掌握

首先我们使用图形界面打开了 gedit、gvim，用 ps 可以查看到

ps aux

 

\#使用9这个信号强制结束 gedit 进程

kill -9 1608

 

\#我们再查找这个进程的时候就找不到了

ps aux | grep gedit

## 5.进程的执行顺序

打开一个程序放在后台，或者用图形界面打开

nice -n -5 vim &

 

\#用 ps 查看其优先级

ps -afxo user,ppid,pid,stat,pri,ni,time,command | grep vim

我们还可以用 renice 来修改已经存在的进程的优先级

renice -5 pid

 