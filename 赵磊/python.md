# 第一个Python程序

## 命令行模式和Python交互模式

1. 在Python交互式模式下，可以直接输入代码，然后执行，并立刻得到结果，因此主要用于调试。
2. 在Python交互模式下输入exit()并回车，就退出了Python交互模式，并回到命令行模式
3. 直接输入python进入交互模式，相当于启动了Python解释器，每输入一行就执行一行。
4. 直接运行.py文件相当于启动了Python解释器，然后一次性把.py文件的源代码给执行了，你是没有机会以交互的方式输入源代码的。

## 输入和输出

### print()

+ 遇到逗号“,”会输出一个空格

+ ```
  >>> a=2
  >>> print(3,a)
  3 2
  >>> print('space',a)
  space 2
  ```

### input()

+ ```
  >>> age  = input('Mike:')
  Mike:25
  >>> age
  '25'
  ```

## 多行输入

+ input()只能输入一行，sys.stdin按下换行键然后ctrl+d程序结束

+ ```
  import sys
  
  obj_list=[]
  for line in sys.stdin:
      obj = line.split()
      if obj == []:
          continue
      obj_list.append(obj)
  print(obj_list)
  
  #运行结果
  zhao
  
  zz
  z
  
  
  z
  [['zhao'], ['zz'], ['z'], ['z']]
  ```

# Python基础

## 数据类型和变量

+ 以#开头的语句是注释
+ 坚持使用4个空格的缩进（在文本编辑器中，需要设置把Tab自动转换为4个空格，确保不混用Tab和空格。
+ 字符串
  + 字符串是以单引号'或双引号"括起来的任意文本，如果字符串内部既包含'又包含"怎么办？可以用转义字符\来标识
  + 用r''表示''内部的字符串默认不转义 robust
  + 用'''...'''的格式表示多行字符串
  + 用True、False表示布尔值（请注意大小写），布尔值可以用and、or和not运算。
    + Python的逻辑运算符可处理字符串和数字，空字符串为假，非空字符串为真。非零的数为真。
    + 对于and操作符：只要左边的表达式为真，整个表达式返回的值是右边表达式的值，否则，返回左边表达式的值 当左边为真时，结果就由右边决定了呗，当左边为假时，还算什么啊，结果肯定是假，也就是返回左边就行了
    + 对于or操作符：只要两边的表达式为真，整个表达式的结果是左边表达式的值。如果两个都是假，返回的是右边的值，如果是一真一假，返回真值表达式的值   如果是一真一假，那就返回真值表达式表示真呗！
  + 空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。
  + 在python中，同一个变量可以反复赋值，而且可以是不同类型的变量，这种变量本身类型不固定的语言称之为动态语言。它是一类在运行时可以改变其结构的语言，比如根据类创建的实例可以任意绑定属性 参考见7.面向对象编程→5.实例属性和类属性
  + 在Python中，通常用全部大写的变量名表示常量：是让你起名时大写，不是说这个变量是内部变量
    PI = 3.14159265359
  + 在Python中，所有数据类型都可以视为对象。爱上ANKI
  + Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在-2147483648-2147483647。Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。
  + 在Python 3.0中，
    + ’/’返回浮点数。
    + ’//’执行Floor(地板除)除法，针对整数操作数截除掉余数返回一个整数，如果有任何一个操作数是浮点数，则返回一个‘浮点数’。

## 字符串和编码

### 字符编码

+ 因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。
+ ASCII编码（American Standard Code for Information Interchange）是由美国人发明的，127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号。
+ 但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。同理，各国文字都有编码。
+ Unicode(Unicode Transformation Format)把所有语言都统一到一套编码里，这样就不会再有乱码问题了。
  ASCII编码是1个字节，而Unicode编码通常是2个字节。
+ 本着节约精神，UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。
+ 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。

### Python的字符串

+ 在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言。

+ 对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把整数(编码)转换为对应的字符。

+ 如果知道字符的整数编码，还可以用十六进制(参考见Python教程→Python基础→字符串和编码→字符编码)这么写str：

+ 由于Python的字符串类型是str，在内存中以Unicode表示，以字符为单位，一个字符对应若干个字节。如果要在网络上传输(以字节进行传输)，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。Python对bytes类型的数据用带b前缀的单引号或双引号表示：

  + ```
    >>> type('中文'.encode('utf-8'))
    	 
    <class 'bytes'>
    >>> type('中文'.encode('unicode-escape'))
    	 
    <class 'bytes'>
    >>> type('中文')
    	 
    <class 'str'>
    ```

+ 要注意区分'ABC'和b'ABC'，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。

+ 以Unicode表示的str通过encode()方法可以编码为指定的bytes,在bytes中，无法显示为ASCII字符的字节，用\x##(且每一个\x表示一个字节)显示。

+ 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str(字符串是Unicode编码)，就需要用decode()方法。

+ 如果bytes中包含无法解码的字节，decode()方法会报错，如果bytes中只有一小部分无效的字节，可以传入errors='ignore'忽略错误的字节。

+ len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数。

+ 实际上，在将unicode存储到文本的过程中，还有一种存储方式，不需要将unicode转换为实际的文本存储字符集(比如utf-8)，而是将unicode的内存编码值进行存储，读取文件的时候再反向转换回来，是采用unicode-escape的转换方式。 转义字符的英文为Escape character

### 格式化

+ 在Python中，采用的格式化方式和C语言是一致的，用%实现

+ 其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数

  + ```
    print('%2d-%02d' % (3, 1))
    print('%.2f' % 3.1415926)
    
    #结果：
     3-01
    3.14
    ```

+ 如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串

+ 有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%

+ 另一种格式化字符串的方法是使用字符串的format()方法,不需要添加%号

  + 使用":", 指定代表元素需要的操作, 如":.3"小数点三位, ":8"占8个字符空间等;
    还可以添加特定的字母, 如'd' - 十进制整数,'o' - 八进制,'b' - 二进制

+ ```
  >>> print('Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125))
  Hello, 小明, 成绩提升了 17.1%
  >>> print('Hello, %s, 成绩提升了 %.1f%%' % ('小明', 17.125))
  Hello, 小明, 成绩提升了 17.1%
  ```

## 使用list和tuple

### list

+ python内置的一种数据类型是列表：list。是种有序的集合，可以随时添加和删除其中的元素。

+ 列出班里所有同学的名字，就可以用一个list表示

  + ```
    >>> classmates = ['Michael', 'Bob', 'Tracy']
    >>> classmates
    ['Michael', 'Bob', 'Tracy']
    ```

+ 用len()函数可以获得list元素的个数

+ 用索引来访问list中每一个位置的元素，记得索引是从0开始的，当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得最后一个元素的索引是len(classmates)-1。

+ 如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素以此类推，可以获取倒数第2个、倒数第3个

+ list是一个可变的有序表，所以，可以往list中追加元素到末尾

+ 也可以把元素插入到指定的位置，比如索引号为1的位置

+ 要删除list末尾的元素，用pop()方法

+ 要删除指定位置的元素，用pop(i)方法，其中i是索引位置

+ 要删除指定位置的元素，用pop(i)方法，其中i是索引位置

+ list元素也可以是另一个list，比如要拿到'php'可以写s[2][1]，因此s可以看成是一个二维数组，类似的还有三维、四维……数组，不过很少用到。

+ 如果一个list中一个元素也没有，就是一个空的list，它的长度为0：

+ extend() 函数用于在列表末尾一次性追加另一个可迭代对象字典也可以(默认是按照key追加)中的多个值

+ index() 函数用于从列表中找出某个值第一个匹配项的索引位置。相当于字符串的find函数

+ sort()和reverse()方法可以对列表进行排序和逆排序

+ 通过加法运算符将列表连接起来，加法运算符还可将字符串连接起来。

  + ```
    >>> [1,2,3]+[4,5,6]
    [1, 2, 3, 4, 5, 6]
    >>> 'hello,'+'world!'
    'hello,world!'
    ```

+ 用数字x乘以一个列表生成一个新列表，即原来的列表被重复x次（字符串也这样）。

  + ```
    >>> 'python'*3
    'pythonpythonpython'
    >>> [31]*3
    [31, 31, 31]
    ```

### tuple

+ 另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改，它没有append()，insert()这样的方法

+ 其他获取元素的方法和list是一样的，可用classmates[0]，classmates[-1]

+ 因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple

+ return a,b返回的其实是tuple，是(a,b)

+ python允许多个值同时赋给多个变量，其实是将一个元组中的每个元素分别赋给每个变量  a,b = 2,4

+ 代码定义一个只有1个元素的tuple( t = (1)定义的是数，()表示数学公式中的小括号)

+ 表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向'a'，就不能改成指向'b'，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！ set是可变对象，其中的元素是不可变对象；tuple是不可变对象，其中的元素既可以是可变对象，又可以是不可变对象

  + ```
    >>> t = ('a', 'b', ['A', 'B'])
    >>> id(t)
    91636320
    >>> print(id(t[0]),id(t[1]),id(t[2]) )
    78845600 78878624 87154080
    >>> t[2][0] = 'X'
    >>> t[2][1] = 'Y'
    >>> t
    ('a', 'b', ['X', 'Y'])
    >>> id(t)
    91636320
    >>> print(id(t[0]),id(t[1]),id(t[2]) )
    78845600 78878624 87154080
    ```

+ 从list取出指定索引的多个元素

  + ```
    >>> import numpy as np
    >>> a=[-2, 1, 5, 3, 8, 5, 6]
    >>> index=[1,3,4]
    >>> a=np.array(a)
    >>> a[index]
    array([1, 3, 8])
    >>> list(a[index])
    [1, 3, 8]
    ```

## 条件判断

+ 条件语句只执行一个语句

  + ```
    age = 20
    if age >= 6:
        print('teenager')
    elif age >= 18:
        print('adult')
    else:
        print('kid')
    ```

## for循环和while循环

+ 计算1→100的和

  + ```
    sum = 0
    for x in range(101):
        sum = sum + x
    print(sum)
    ```

+ for循环里，同时引用了两个变量，在Python里是很常见的

  + ```
    >>> for x, y in [(1, 1), (2, 4), (3, 9)]:
    	print(x, y)
    
    1 1
    2 4
    3 9
    ```

+ while：计算100以内所有奇数和

  + ```
    sum = 0
    n = 99
    while n > 0:
        sum = sum + n
        n = n - 2
    print(sum)
    ```

## break和continue

+ break: 打印出1~10后，紧接着打印END，程序结束

  + ```
    n = 1
    while n <= 100:
        if n > 10: # 当n = 11时，条件满足，执行break语句
            break # break语句会结束当前循环
        print(n)
        n = n + 1
    print('END')
    ```

+ continue:打印的不再是1～10，而是1，3，5，7，9。

  + ```
    n = 0
    while n < 10:
        n = n + 1
        if n % 2 == 0: # 如果n是偶数，执行continue语句
            continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行
        print(n)
    ```

## 使用dict和set

### dict

+ dict在内部就可以直接计算出Michael对应的存放成绩的“页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快。

+ 把数据放入dict的方法，除了初始化时指定外，还可以通过key放入

+ 通过in判断key是否存在

+ 通过dict提供的get()判断key是否存在；Python 字典(Dictionary) get() 函数返回指定键的值，如果值不在字典中返回默认值。

+ 通过dict提供的get()判断key是否存在；Python 字典(Dictionary) get() 函数返回指定键的值，如果值不在字典中返回默认值。

+ 要删除一个key，用pop(key)方法，对应的value也会从dict中删除

+ dict的key必须是不可变对象，这个通过key计算位置的算法称为哈希算法（Hash）。在Python中，字符串、整数、元组等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key。

  + ```
    >>> key = [1, 2, 3]
    >>> d[key] = 'a list'
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: unhashable type: 'list'
    ```

### set

+ set和dict的唯一区别仅在于没有存储对应的value

+ set的原理和dict一样，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”

+ 试试把list放入set，看看是否会报错（会，因为list都不能作为dict的关键字，自然也就不能作为set的关键字了）

+ set是可变对象，其中的元素是不可变对象；tuple是不可变对象，其中的元素既可以是可变对象，又可以是不可变对象

+ 要创建一个set，可以使用{},也可以提供list或tuple作为输入集合，使用set()进行转换，重复元素在set中自动被过滤

  + ```
    >>> L1 = [1,1,2,4,3]  
    >>> T1 = (2,4,6,6,6,7)  
    >>> s = {1}  
    >>> type(s)  
    <class 'set'>  
    >>> s = set(L1) #从列表到集合  
    >>> s  
    {1, 2, 3, 4}  
    >>> s = set(T1) #从tuple到set  
    >>> s  
    {2, 4, 6, 7}
    ```

+ 通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果

  + ```
    >>> s.add(4)
    >>> s
    {1, 2, 3, 4}
    >>> s.add(4)
    >>> s
    {1, 2, 3, 4}
    ```

+ 通过remove(key)方法可以删除元素

  + ```
    >>> s.remove(4)
    >>> s
    {1, 2, 3}
    ```

+ set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作

  + ```
    >>> s1 = set([1, 2, 3])
    >>> s2 = set([2, 3, 4])
    >>> s1 & s2
    {2, 3}
    >>> s1 | s2
    {1, 2, 3, 4}
    
    #&不是and，|也不是or
    #&和|与集合一起使用时，分别表示交集和并集
    ```

## 可变对象与不可变对象 

+ 不可变对象：int，string，float，tuple；可变对象 ：list，dict，set

+ set是可变对象，其中的元素是不可变对象；tuple是不可变对象，其中的元素既可以是可变对象，又可以是不可变对象

+ python中的变量存放的是对象引用

+ 对于不可变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回

+ 同时，引用发生了改变

  + 对list进行操作

  ```
  >>> a = ['c', 'b', 'a']
  >>> id(a)
  91717464
  >>> a.sort()
  >>> a
  ['a', 'b', 'c']
  >>> id(a)
  91717464
  ```
  + 对str进行操作

  ```
  >>> a = 'abc'
  >>> id(a)
  78941440
  >>> a=a.replace('a', 'A')
  >>> a
  'Abc
  >>> id(a)
  86997824
  ```

+ python中的变量存放的是对象引用，如果需要拷贝对象，需要使用标准库中的copy模块。

  + copy.copy 浅拷贝 拷贝父对象，不会拷贝对象的内部的子对象也就是说子对象还是引用
  + copy.deepcopy 深拷贝 拷贝对象及其子对象也就是说全不是引用了

  ```
  >>> import copy
  >>> a = [1,2,3,4,['a','b']]  #原始对象
  >>> b = a  #赋值，传对象的引用
  >>> c = copy.copy(a)
  >>> d = copy.deepcopy(a)
  >>> a.append(5)
  >>> a[4].append('c')
  >>> a
  [1, 2, 3, 4, ['a', 'b', 'c'], 5]
  >>> b
  [1, 2, 3, 4, ['a', 'b', 'c'], 5]
  >>> c
  [1, 2, 3, 4, ['a', 'b', 'c']]
  >>> d
  [1, 2, 3, 4, ['a', 'b']]
  ```

# 函数

