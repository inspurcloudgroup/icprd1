# Linux基础
## Linux下软件安装
通常 Linux 上的软件安装主要有四种方式：在线安装、从磁盘安装deb软件包、从二进制软件包安装、从源代码编译安装
### 1、apt包管理工具
APT是Advance Packaging Tool（高级包装工具）的缩写，是Debian及其派生发行版的软件包管理器，APT可以自动下载，配置，安装二进制或者源代码格式的软件包，因此简化了Unix系统上管理软件的过程。

在执行安装操作时，首先apt-get 工具会在**本地**的一个数据库中搜索关于软件的相关信息，并根据这些信息在相关的**服务器**上下载软件安装。若手动更换了源或需要更新软件包列表，可以执行`apt update`操作。

apt命令常用工具：
工具|说明
:--:|:--:
install|其后加上软件包名，用于安装一个软件包
update|从软件源镜像服务器上下载/更新用于更新本地软件源的软件包列表
upgrade|升级本地可更新的全部软件包，但存在依赖问题时将不会升级，通常会在更新之前执行一次update
dist-upgrade|解决依赖关系并升级(存在一定危险性)
remove|移除已安装的软件包，包括与被移除软件包有依赖关系的软件包，但不包含软件包的配置文件
autoremove|移除之前被其他软件包依赖，但现在不再被使用的软件包
purge|与remove相同，但会完全移除软件包，包含其配置文件
clean|移除下载到本地的已经安装的软件包，默认保存在/var/cache/apt/archives/
autoclean|移除已安装的软件的旧版本软件包
常用参数：
参数|说明
:--:|:--:
-y|自动回应是否安装软件包的选项，在一些自动化安装脚本中使用这个参数将十分有用
-s|模拟安装
-q|静默安装方式，指定多个q或者-q=#,#表示数字，用于设定静默级别，这在你不想要在安装软件包时屏幕输出过多时很有用
-f|修复损坏的依赖关系
-d|只下载不安装
--reinstall|重新安装已经安装但可能存在问题的软件包
--install-suggests|同时安装APT给出的建议安装的软件包
### 2、软件搜索
	
	 apt-cache search softname1 softname2 softname3……
### 3、dpkg的使用
使用 dpkg 从本地磁盘安装 deb 软件包
dpkg常用参数：
参数|说明
:--: | :--:
-i|安装指定deb包
-R|后面加上目录名，用于安装该目录下的所有deb安装包
-r|remove，移除某个已安装的软件包
-I|显示deb包文件的信息
-s|显示已安装软件的信息
-S|搜索已安装的软件包
-L|显示已安装软件包的目录信息
使用dpkg安装时如果有依赖包不会自动安装，此时使用`apt`工具，`-f`参数为修复损坏的依赖关系
### 4、从二进制包安装
将从网络上下载的二进制包解压后放到合适的目录，然后将包含可执行的主程序文件的目录添加进PATH环境变量即可
## Linux进程概念
### 1、程序与进程
程序只是一些列指令的集合，是一个静止的实体，而进程不同，进程有以下的特性：
* 动态性：进程的实质是一次程序执行的过程，有创建、撤销等状态的变化。而程序是一个静态的实体。
* **并发**性：进程可以做到在一个时间段内，有多个程序在运行中。程序只是静态的实体，所以不存在并发性。
* 独立性：进程可以独立分配资源，独立接受调度，独立地运行。
* 异步性：进程以不可预知的速度向前推进。
* 结构性：进程拥有代码段、数据段、**PCB（进程控制块，进程存在的唯一标志）**。也正是因为有结构性，进程才可以做到独立地运行。

> 并发：在一个时间段内，宏观来看有多个程序都在活动，有条不紊的执行（每一瞬间只有一个在执行，只是在一段时间有多个程序都执行过）

> 并行：在每一个瞬间，都有多个程序都在同时执行，这个必须有多个 CPU 才行

**线程**（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率。

**总结**：一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
### 2、进程
#### 进程的分类
1、根据进程的功能与服务对象：
* 用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。
* 系统进程：通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预，即使是 root 用户也不能干预系统进程的运行。

2、根据应用程序的服务类型：
* 交互进程：由一个 shell 终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。
* 批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。
* 守护进程：守护进程是一直运行的一种进程，在 Linux 系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如 httpd 进程，一直处于运行状态，等待用户的访问。还有经常用的 cron（在 centOS 系列为 crond）进程，这个进程为 crontab 的守护进程，可以周期性的执行用户设定的某些任务。
#### 进程的衍生
由父进程可以创建出子进程
> fork() 是一个系统调用（system call），它的主要作用就是为当前的进程创建一个新的进程，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如进程的执行代码段，内存信息，文件描述，寄存器状态等等
> exec() 也是系统调用，作用是切换子进程中的执行程序也就是替换其从父进程复制过来的代码段与数据段

子进程就是父进程通过系统调用 fork() 而产生的复制品，fork() 就是把父进程的 PCB 等进程的数据结构信息直接复制过来，只是修改了 PID，所以一模一样，只有在执行 exec() 之后才会不同。

##### 僵尸进程
在将要结束时的子进程代码执行部分已经结束执行了，系统的资源也基本归还给系统了，但若是其进程的进程控制块（PCB）仍驻留在内存中，而它的 PCB 还在，代表这个进程还存在（因为 PCB 就是进程存在的唯一标志，里面有 PID 等消息），并没有消亡，这样的进程称之为僵尸进程（Zombie）。正常情况下，父进程会收到两个返回值：exit code（SIGCHLD 信号）与 reason for termination 。之后，父进程会使用 wait(&status) 系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的 PCB；而如若父进程没有这么做的话，子进程的 PCB 就会一直驻留在内存中，一直留在系统中成为僵尸进程。

僵尸进程的问题： Linux 系统中能使用的 PID 是有限的，如果系统中存在有大量的僵尸进程，系统将会因为没有可用的 PID 从而导致不能产生新的进程。
##### 孤儿进程
如果父进程结束（非正常的结束），未能及时收回子进程，子进程仍在运行，这样的子进程称之为孤儿进程。在 Linux 系统中，孤儿进程一般会被 init 进程所“收养”，成为 init 的子进程。由 init 来做善后处理，所以它并不至于像僵尸进程那样无人问津，不管不顾，大量存在会有危害。

查看进程信息可以使用一个命令：

	ps －fxo user,ppid,pid,pgid,command
	# pid：该进程的一个唯一编号
	# ppid：该进程的父进程的 pid
	# command：该进程通过执行什么样的命令或者脚本而产生的
#### 进程组与Sessions
每一个进程都会是一个**进程组**的成员，而且这个进程组是唯一存在的，他们是依靠 PGID（process group ID）来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。

一般情况，进程组的 PGID 等同于进程组的第一个成员的 PID，并且这样的进程称为该进程组的领导者,也就是领导进程，进程一般通过使用 `getpgrp()` 系统调用来寻找其所在组的 PGID，领导进程可以先终结，此时进程组依然存在，并持有相同的PGID，直到进程组中最后一个进程终结。

与进程组类似，每当一个进程被创建的时候，它便会成为其父进程所在 Session 中的一员，每一个进程组都会在一个 Session 中，并且这个 Session 是唯一存在的，

Session 主要是针对一个 tty 建立，Session 中的每个进程都称为一个工作(job)。每个会话可以连接一个终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。Session 意义在于将多个 jobs 囊括在一个终端，并取其中的一个 job 作为前台，来直接接收该终端的输入输出以及终端信号。 其他 jobs 在后台运行。
#### 工作管理
* 前台运行的程序通过`ctrl+c`可停止运行
* 在命令后加`&`符号可以让命令在后台运行
* 通过 `ctrl + z` 可以使当前工作停止并丢到后台中去
* 被停止并放置在后台的工作可以使用命令`jobs`查看
![图片描述](https://dn-simplecloud.shiyanlou.com/courses/uid1079991-20190527-1558949620825)
`1`表示job，编号`+`表示刚刚（最后一个）放到后台的job，若是倒数第二个为`-`，其他的则无符号
使用命令`fg [%jobnumber]`，可将job调到前台，不加参数默认为最后一个放入后台的job，使用命令`bg [%jobnumber]`可使job在后台运行
删除job
```
kill -signal %jobnumber #若后面跟pid则为删除进程
```

常用信号值：

| 信号值 | 作用 |
|:---: | --- |
| `-1` | 重新读取参数运行，类似与restart |
| `-2` | 如同 ctrl+c 的操作退出 |
| `-9` | 强制终止该任务 |
| `-15` | 正常的方式终止该任务 |
