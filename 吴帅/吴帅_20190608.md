```
                             学习总结
```

------



## 今日学习内容

1.学习项目    

- linux

  - linux基本操作

    tab 键自动补齐命令

    ctrl + C        强行终止程序

    ctrl  + d       输入结束或退出终端

    ctrl + s    暂停、任意键继续

    ctrl + 空格       向前删除一个字符

    ctrl  + k  删除光标之后的

    man   查看help

    ls  --help

    who am i / who mom likes         查看用户信息

    sudo adduser    username     添加用户

    su username 切换用户

    groups  username    查看用户组

    

    通过cat相关文件查看用户组：

    sudo  cat  /etc/sudoers.d/shiyanlou（root用户）

    cat  /etc/group | sort

    

    usermod        user 加入sudo用户组

    sudo deluser username  --remove-home

    ls -a 查看隐藏文件

    ls    == dir

    ls -l         查看目录下所有文件的权限

    ls -A

    ls -Al

    ls - dl    目录属性

    ls -AsSh    文件大小

    上下键

  - 软件的安装

    通常在Linux上的软件安装主要有四种方式。

    在线安装、从磁盘安装deb软件包、从二进制软件包安装、从源代码编译安装。

    但是在 Linux 下，一个命令加回车，等待一下，软件就安装好了，这就是方便的在线安装软件的方式。在学习这种安装方式之前有一点需要说明的是，**在不同的linux发行版上面在线安装方式会有一些差异包括使用的命令及它们的包管理工具**

  - 软件安装操作

    > sudo apt-get install w3m    //安装w3m软件
    >
    > **注意**:如果你在安装一个软件之后，无法立即使用`Tab`键补全这个命令，你可以尝试先执行`source ~/.zshrc`，然后你就可以使用补全操作。
    >
    > man w3m
    >
    > q // 退出

  - apt管理包介绍

    > APT是Advance Packaging Tool（高级包装工具）的缩写，是Debian及其派生发行版的软件包管理器，APT可以自动下载，配置，安装二进制或者源代码格式的软件包，因此简化了Unix系统上管理软件的过程。APT最早被设计成dpkg的前端，用来处理deb格式的软件包。现在经过APT-RPM组织修改，APT已经可以安装在支持RPM的系统管理RPM包。这个包管理器包含以 `apt-` 开头的多个工具，如 `apt-get` `apt-cache` `apt-cdrom` 等，在Debian系列的发行版中使用。

    当你在执行安装操作时，首先`apt-get` 工具会在**本地**的一个数据库中搜索关于 `w3m` 软件的相关信息，并根据这些信息在相关的服务器上下载软件安装，这里大家可能会一个疑问：既然是在线安装软件，为啥会在本地的数据库中搜索？要解释这个问题就得提到几个名词了：

    - **软件源镜像服务器**
    - **软件源**

    我们需要定期从服务器上下载一个软件包列表，使用 `sudo apt-get update` 命令来保持本地的软件包列表是最新的（有时你也需要手动执行这个操作，比如更换了软件源），而这个表里会有**软件依赖**信息的记录，对于软件依赖，我举个例子：我们安装 `w3m` 软件的时候，而这个软件需要 `libgc1c2` 这个软件包才能正常工作，这个时候 `apt-get` 在安装软件的时候会一并替我们安装了，以保证 `w3m` 能正常的工作。

  - apt-get使用

    `apt-get` 是用于处理 `apt`包的公用程序集，我们可以用它来在线安装、卸载和升级软件包等，下面列出一些`apt-get`包含的常用的一些工具：

    | 工具           | 说明                                                         |
    | -------------- | ------------------------------------------------------------ |
    | `install`      | 其后加上软件包名，用于安装一个软件包                         |
    | `update`       | 从软件源镜像服务器上下载/更新用于更新本地软件源的软件包列表  |
    | `upgrade`      | 升级本地可更新的全部软件包，但存在依赖问题时将不会升级，通常会在更新之前执行一次`update` |
    | `dist-upgrade` | 解决依赖关系并升级(存在一定危险性)                           |
    | `remove`       | 移除已安装的软件包，包括与被移除软件包有依赖关系的软件包，但不包含软件包的配置文件 |
    | `autoremove`   | 移除之前被其他软件包依赖，但现在不再被使用的软件包           |
    | `purge`        | 与remove相同，但会完全移除软件包，包含其配置文件             |
    | `clean`        | 移除下载到本地的已经安装的软件包，默认保存在/var/cache/apt/archives/ |
    | `autoclean`    | 移除已安装的软件的旧版本软件包                               |

    下面是一些`apt-get`常用的参数：

    | 参数                 | 说明                                                         |
    | -------------------- | ------------------------------------------------------------ |
    | `-y`                 | 自动回应是否安装软件包的选项，在一些自动化安装脚本中使用这个参数将十分有用 |
    | `-s`                 | 模拟安装                                                     |
    | `-q`                 | 静默安装方式，指定多个`q`或者`-q=#`,#表示数字，用于设定静默级别，这在你不想要在安装软件包时屏幕输出过多时很有用 |
    | `-f`                 | 修复损坏的依赖关系                                           |
    | `-d`                 | 只下载不安装                                                 |
    | `--reinstall`        | 重新安装已经安装但可能存在问题的软件包                       |
    | `--install-suggests` | 同时安装APT给出的建议安装的软件包                            |

    重新安装：当软件文件被系统破坏、或者一些错误配置导致软件无法正常工作。

    > sudo apt-get  -- reinstall install w3m

    另一个需要掌握的是，如何在不知道软件包完整名的时候进行安装。通常我们是使用`Tab`键补全软件包名，学习一下更好的方法来搜索软件包。

    有时候需要同时安装多个软件包，可以使用正则表达式匹配软件包名进行批量安装。

  - 软件升级

    > sudo apt-get update	//更新软件源
    >
    > sudo apt-get upgrade  	//升级没有依赖问题的软件包
    >
    > sudo apt-get dist-upgrade	//升级并解决依赖问题

  - 卸载软件

    > sudo apt-get remove w3m
    >
    > sudo apt-get purge w3m   //相关配置文件也清除
    >
    > sudo apt-get  --purge remove
    >
    > sudo apt-get autoremove // 移除不再需要的被依赖的软件包

  - 软件搜索

    当自己刚知道了一个软件，想下载使用，需要确认软件仓库里面有没有，就需要用到搜索功能了，命令如下：

    ```
    sudo apt-cache search softname1 softname2 softname3……
    ```

    `apt-cache` 命令则是针对本地数据进行相关操作的工具，`search` 顾名思义在本地的数据库中寻找有关 `softname1``softname2` …… 相关软件的信息。

  - dpkg

    使用dpkg在本地磁盘安装deb软件包。

    > dpkg 是 Debian 软件包管理器的基础，它被伊恩·默多克创建于 1993 年。dpkg 与 RPM 十分相似，同样被用于安装、卸载和供给和 .deb 软件包相关的信息。

    > dpkg 本身是一个底层的工具。上层的工具，像是 APT，被用于从远程获取软件包以及处理复杂的软件包关系。"dpkg"是"Debian Package"的简写。

    我们经常可以在网络上见到以`deb`形式打包的软件包，就需要使用`dpkg`命令来安装。

    `dpkg`常用参数介绍：

    | 参数 | 说明                                            |
    | ---- | ----------------------------------------------- |
    | `-i` | 安装指定deb包                                   |
    | `-R` | 后面加上目录名，用于安装该目录下的所有deb安装包 |
    | `-r` | remove，移除某个已安装的软件包                  |
    | `-I` | 显示`deb`包文件的信息                           |
    | `-s` | 显示已安装软件的信息                            |
    | `-S` | 搜索已安装的软件包                              |
    | `-L` | 显示已安装软件包的目录信息                      |

  - 使用dpkg安装deb软件包

    > apt-get 能远程下载
    >
    > sudo apt-get -d software
    >
    > sudo apt-get -d emacs   //远程下载emacs编辑器的deb包
    >
    > 查看：
    >
    > /var/cache/apt/archives/
    >
    > cp deb包到目录下
    >
    > 安装之前查看deb包的信息
    >
    > sudo dpkg -I 包name
    >
    > 安装：
    >
    > sudo dpkg -i 包名

    安装出错：依赖关系问题、配置未配置

    > sudo apt-get update
    >
    > sudo apt-get -f install     //-f  修复依赖关系的安装

  - 查看软件安装目录

    > sudo dpkg -L emacs24

  - 安装二进制文件

    二进制包的安装比较简单，我们需要做的只是将从网络上下载的二进制包解压后放到合适的目录，然后将包含可执行的主程序文件的目录添加进`PATH`环境变量即可，如果你不知道该放到什么位置，请重新复习第四节关于 Linux 目录结构的内容。

  - 进程管理

    在Linux操作过程中，我们需要对进程进行查看和控制，在进程出现异常时及时查看相关指标，从而解决问题。

    查看进程运行状态、进程的结束控制、进程的执行顺序。

  - 查看进程

    通过top实时查看进程状态和系统的一些信息（cpu、memory、disk、etc），and通过ps可以静态查看当前的进程信息。同时可以使用pstree来查看当前活跃的进程的树形结构。

    > top
    >
    > top 是一个在前台执行的程序，所以执行后便进入到这样的一个交互界面，正是因为交互界面我们才可以实时的获取到系统与进程的信息。在交互界面中我们可以通过一些指令来操作和筛选。在此之前我们先来了解显示了哪些信息。
    >
    > 我们看到 top 显示的第一排，
    >
    > | 内容                         | 解释                                |
    > | ---------------------------- | ----------------------------------- |
    > | top                          | 表示当前程序的名称                  |
    > | 11:05:18                     | 表示当前的系统的时间                |
    > | up 8 days,17:12              | 表示该机器已经启动了多长时间        |
    > | 1 user                       | 表示当前系统中只有一个用户          |
    > | load average: 0.29,0.20,0.25 | 分别对应1、5、15分钟内cpu的平均负载 |
    >
    > load average 在 wikipedia 中的解释是 the system load is a measure of the amount of work that a computer system is doing 也就是对当前 CPU 工作量的度量，具体来说也就是指运行队列的平均长度，也就是等待 CPU 的平均进程数相关的一个计算值。
    >
    > 我们该如何看待这个load average 数据呢？
    >
    > 假设我们的系统是单 CPU、单内核的，把它比喻成是一条单向的桥，把CPU任务比作汽车。
    >
    > - load = 0 的时候意味着这个桥上并没有车，cpu 没有任何任务；
    > - load < 1 的时候意味着桥上的车并不多，一切都还是很流畅的，cpu 的任务并不多，资源还很充足；
    > - load = 1 的时候就意味着桥已经被车给占满了，没有一点空隙，cpu 的已经在全力工作了，所有的资源都被用完了，当然还好，这还在能力范围之内，只是有点慢而已；
    > - load > 1 的时候就意味着不仅仅是桥上已经被车占满了，就连桥外都被占满了，cpu 已经在全力工作，系统资源的用完了，但是还是有大量的进程在请求，在等待。若是这个值大于２、大于３，表示进程请求超过 CPU 工作能力的 2 到 ３ 倍。而若是这个值 > 5 说明系统已经在超负荷运作了。
    >
    > 这是单个 CPU 单核的情况，而实际生活中我们需要将得到的这个值除以我们的核数来看。我们可以通过以下的命令来查看 CPU 的个数与核心数
    >
    > 查看cpu个数
    >
    > cat /proc/cpuinfo |grep "physical id"|sort |uniq|wc -1
    >
    > 每个cpu的核心数
    >
    > cat /pro/cpuinfo |grep "physical id"|grep "0"|wc -1

  - ps

    输出当前进程的快照。

    > ps [options]
    >
    > ps aux  // 罗列所有进程信息
    >
    > ps aux | grep zsh  //用正则表达式查询某一个进程
    >
    > ps axjf //查看并输出树状
    >
    > ps -afxo user,ppid,pidpgid,command 	//自定义输出
    >
    > ps -l 显示自己本次登陆bash相关的进行信息

  - pstree

    > pstree  	//可看到相同的进程数量（ps)，主要还是能看到进程之间的联系（相关性）。
    >
    > pstree -Aup
    >
    > -A 各进程间用ASCII字元连接
    >
    > -p同时列出进程的PID
    >
    > -u列出进程所属账户信息

  - 进程管理

    掌握kill命令

    当一个进程结束的时候或者要异常结束的时候，会向其父进程返回一个或者接收一个 SIGHUP 信号而做出的结束进程或者其他的操作，这个 SIGHUP 信号不仅可以由系统发送，我们可以使用 kill 来发送这个信号来操作进程的结束或者重启等等。

     kill 命令可以管理 job，我们可以尝试用 kill 来操作下一些不属于 job 范畴的进程，直接对 pid 下手。

  - kill操作

    > kill -9 pid   //用9这个信号强制结束进程
    >
    > 然后就查看不到
    >
    > ps aux | grep name

  - 进程执行顺序

    进程调度靠该进程的优先级值来判定进程调度的优先级，而优先级的值就是上文所提到的 PR 与 nice 来控制与体现了

    而 nice 的值我们是可以通过 nice 命令来修改的，而需要注意的是 nice 值可以调整的范围是 -20 ~ 19，其中 root 有着至高无上的权力，既可以调整自己的进程也可以调整其他用户的程序，并且是所有的值都可以用，而普通用户只可以调制属于自己的进程，并且其使用的范围只能是 0 ~ 19，因为系统为了避免一般用户抢占系统资源而设置的一个限制。

    > renice -5 pid	//修改优先级
    >
    > 查看优先级
    >
    > ps -afxo user,ppid,pgid,pid,pri,ni,time,command | grep name

- java

  - 多线程

    ava 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。

    包括：线程生命周期、线程变量、线程同步、lock、unlock、死锁、生产者消费者模式、线程池。

  - 线程

    线程：程序执行流的最小单元。它是进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派 CPU 的基本单位。

    线程的生老病死：

    new --> runable--> (blocked) -->running -->dead(java01)

    结合线程的生命周期来看看多线程的定义：

    > 多线程：从软件或者硬件上实现多个线程并发执行的技术。在单个程序中同时运行多个线程完成不同的工作。

    在 Java 中，[垃圾回收机制](http://baike.baidu.com/view/159846.htm)就是通过一个线程在后台实现的，这样做的好处在于：开发者通常不需要为内存管理投入太多的精力。反映到我们现实生活中，在浏览网页时，浏览器能够同时下载多张图片；实验楼的服务器能够容纳多个用户同时进行在线实验，这些都是多线程带来的好处。

    从专业的角度来看，多线程编程是为了最大限度地利用 CPU 资源——当处理某个线程不需要占用 CPU 而只需要利用 IO 资源时，允许其他的那些需要 CPU 资源的线程有机会利用 CPU。这或许就是多线程编程的最终目的。当然，你也可以进一步了解。

    对于多线程和线程之间的关系，你可以这样理解：一个使用了多线程技术的程序，包含了两条或两条以上并发运行的线程（`Thread`）。

  - 实现多线程

    多线程的形式上实现方式主要有两种，一种是继承Thread类，一种是实现Runnable接口。本质上实现方式都是来实现线程任务，然后启动线程执行线程任务（这里的线程任务实际上就是run方法）。这里所说的6种，实际上都是在以上两种的基础上的一些变形。

    1、继承Thread Class

    2、实现Runnable interface

    3、lambda方式创建

    等等

  - 继承Thread类

    > package com.ws.treadex;
    >
    > public class Thread1 extends Thread {
    >  @Override
    >  public void run() {
    >      //在run()方法中放入线程要完成的工作
    >
    > ```
    >  //这里我们把两个线程各自的工作设置为打印100次信息
    >  for (int i = 0; i < 100; ++i) {
    >      System.out.println("Hello! This is " + i);
    >  }
    >  
    >  //在这个循环结束后，线程便会自动结束
    > ```
    >
    >  }
    > }

  - 实现Runnable interface

    > ```
    > package com.ws.treadex;
    > 
    > class Thread2 implements Runnable {
    >  //与Thread1不同，如果当一个线程已经继承了另一个类时，就建议你通过实现Runnable接口来构造
    > 
    >  @Override
    >  public void run() {
    >      for (int i = 0; i < 100; ++i) {
    >          System.out.println("Thanks. There is " + i);
    >      }
    >  }
    > }
    > ```

  - 线程共享变量和线程变量

    ThreadLocal，即线程变量，是一个以 ThreadLocal 对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个 ThreadLocal 对象查询到绑定在这个线程上的一个值。
    可以通过 set(T)方法来设置一个值，在当前线程下再通过 get()方法获取到原先设置的值。

    example：

    > ```
    > public class ThreadLocalDemo {
    > 
    >  public static void main(String[] args) {
    >      ThreadDemo threadDemo = new ThreadDemo();
    >      //启动2个线程
    >      new Thread(threadDemo).start();
    >      new Thread(threadDemo).start();
    > 
    >  }
    > }
    > 
    > class ThreadDemo implements Runnable {
    >  //使用ThreadLocal提供的静态方法创建一个线程变量 并且初始化值为0
    >  private static ThreadLocal<Integer> threadLocal = ThreadLocal.withInitial(() -> 0);
    > 
    >  @Override
    >  public void run() {
    >      for (int i = 0; i < 10; i++) {
    >          //get方法获取线程变量值
    >          Integer integer = threadLocal.get();
    >          integer += 1;
    >          //set方法设置线程变量值
    >          threadLocal.set(integer);
    >          System.out.println(integer);
    >      }
    >  }
    > }
    > 通过控制台的结果可以看到，两个线程之间的变量互不干涉。
    > ```

    线程共享变量

    > 如果我们去掉了 ThreadLocal，其他的流程都不改变，已经使用 2 个线程自增变量会如何呢？`
    >
    > ```
    > public class ThreadLocalDemo {
    > 
    >  public static void main(String[] args) {
    >      ThreadDemo threadDemo = new ThreadDemo();
    >      new Thread(threadDemo).start();
    >      new Thread(threadDemo).start();
    > 
    >  }
    > }
    > 
    > class ThreadDemo implements Runnable {
    >  private Integer integer = 0;
    > 
    >  @Override
    >  public void run() {
    >      for (int i = 0; i < 10; i++) {
    >          integer++;
    >          System.out.println(integer);
    >      }
    >  }
    > }
    > ~在没有加入 ThreadLocal 的情况下，发现 integer 变量的值增加到了 20，那是因为这个时候两个线程都是使用同一对象threadDemo的变量，这个时候的 integer 就变成了线程共享变量，如果同学们多运行几次，还有可能出现最后结果是 18 19 的情况，那是因为如果不做任何处理，线程共享变量都不是线程安全的，也就是说在多线程的情况下，共享变量有可能会出错。~
    > ```

  - 线程同步

    本身线程是异步的。但是，当多个线程操作同一个对象时，就会出现线程安全问题，被多个线程同时操作的对象数据可能会发生错误。线程同步可以保证在同一个时刻该对象只被一个线程访问。

    - Synchronized

    关键字 synchronized 可以修饰方法或者以同步块的形式来进行使用，它确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，保证了线程对变量访问的可见性和排他性。它有三种使用方法：

    - 对普通方式使用，将会锁住当前实例对象
    - 对静态方法使用，将会锁住当前类的 Class 对象
    - 对代码块使用，将会锁住代码块中的对象

    > 在下面的代码中，演示了三种加锁方式。
    >
    > ```
    > public class SynchronizedDemo {
    >  private static Object lock = new Object();
    > 
    >  public static void main(String[] args) {
    >      //同步代码块 锁住lock
    >      synchronized (lock) {
    >          //doSomething
    >      }
    >  }
    > 
    >  //静态同步方法  锁住当前类class对象
    >  public synchronized static void staticMethod(){
    > 
    >  }
    >  //普通同步方法  锁住当前实例对象
    >  public synchronized void memberMethod() {
    > 
    >  }
    > }
    > ```

  - java.util.concurrent

    ava.util.concurrent 包是 java5 开始引入的并发类库，提供了多种在并发编程中的适用工具类。包括原子操作类，线程池，阻塞队列，Fork/Join 框架，并发集合，线程同步锁等。

  - lock\unlock

    JUC 中的 ReentrantLock 是多线程编程中常用的加锁方式，ReentrantLock 加锁比 synchronized 加锁更加的灵活，提供了更加丰富的功能。

    > ```
    > package com.ws.lockex;
    > 
    > import java.util.concurrent.locks.ReentrantLock;
    > 
    > public class LockDemo {
    >  private static ReentrantLock lock = new ReentrantLock();
    > 
    >  public static void main(String[] args) {
    >      Thread thread1 = new Thread(() -> {
    >          lock.lock();
    >          try {
    >              //需要同步的代码块
    >              System.out.println("线程1加锁");
    >          }finally {
    > //                一定要在finally中解锁，否则可能造成死锁
    >              lock.unlock();
    >              System.out.println("线程1解锁");
    >          }
    >      });
    >      thread1.start();
    >      Thread thread2 = new Thread(() -> {
    >          lock.lock();
    >          try {
    >              System.out.println("线程2加锁");
    >          }finally {
    >              lock.unlock();
    >              System.out.println("线程2解锁");
    >          }
    >      });
    >      thread2.start();
    >  }
    > 
    > }
    > ```

  - 死锁

    在多线程环境下，锁的使用非常频繁，但是它会带来一下问题，比如死锁。当死锁发生时，系统将会瘫痪。比如两个线程互相等待对方释放锁。

    > ```
    > public class DeadLockDemo {
    >  private static Object lockA = new Object();
    >  private static Object lockB = new Object();
    > 
    >  public static void main(String[] args) {
    >      //这里使用lambda表达式创建了一个线程  
    >      //线程  1
    >      new Thread(() -> {
    >          synchronized (lockA) {
    >              try {
    >                  //线程休眠一段时间  确保另外一个线程可以获取到b锁
    >                  Thread.sleep(1000);
    >              } catch (InterruptedException e) {
    >                  e.printStackTrace();
    >              }
    >              System.out.println("D");
    >              synchronized (lockB) {
    >              }
    >          }
    >      }).start();
    >      //线程 2
    >      new Thread(() -> {
    >          synchronized (lockB) {
    >              System.out.println("死锁...");
    >              synchronized (lockA) {
    >              }
    >          }
    >      }).start();
    >  }
    > }
    > ```
    >
    > 在上面的编程实例中，线程 1 获取了 lockA 的锁后再去获取 lockB 的锁，而此时 lockB 已经被线程 2 获取，同时线程 2 也想获取 lockA，两个线程进这样僵持了下去，谁也不让，造成了死锁。在编程时，应该避免死锁的出现。

  - 饥饿

    饥饿是指一个可运行的进程尽管能继续执行，但被调度器无限期地忽视，而不能被调度执行的情况。

    比如当前线程处于一个低优先级的情况下，操作系统每次都调用高优先级的线程运行，就会导致当前线程虽然可以运行，但是一直不能被运行的情况。

  - 线程的生命周期

    线程的声明周期共有 6 种状态，分别是：新建`New`、运行（可运行）`Runnable`、阻塞`Blocked`、计时等待`Timed Waiting`、等待`Waiting`和终止`Terminate`。

    > 当你声明一个线程对象时，线程处于新建状态，系统不会为它分配资源，它只是一个空的线程对象。

    > 调用`start()`方法时，线程就成为了可运行状态，至于是否是运行状态，则要看系统的调度了。

    > 调用了`sleep()`方法、调用`wait()`方法和 IO 阻塞时，线程处于等待、计时等待或阻塞状态。

    > 当`run()`方法执行结束后，线程也就终止了。

  - ArrayBlockQueue

    ArrayBlockingQueue 是由数组支持的有界阻塞队列。位于`java.util.concurrent`包下。

    首先看看其构造方法:

    | 构造方法                                                     | 描述                                               |
    | ------------------------------------------------------------ | -------------------------------------------------- |
    | public ArrayBlockingQueue(int capacity)                      | 构造大小为 capacity 的队列                         |
    | public ArrayBlockingQueue(int capacity, boolean fair)        | 指定队列大小，以及内部实现是公平锁还是非公平锁     |
    | public ArrayBlockingQueue(int capacity, boolean fair, Collection<? extends E> c) | 指定队列大小，以及锁实现，并且在初始化是加入集合 c |

    入队常用方法：

    | 入队方法 | 队列已满     | 队列未满   |
    | -------- | ------------ | ---------- |
    | add      | 抛出异常     | 返回 true  |
    | offer    | 返回 false   | 返回 true  |
    | put      | 阻塞直到插入 | 没有返回值 |

    出队常用方法

    | 出队方法 | 队列为空     | 队列不为空     |
    | -------- | ------------ | -------------- |
    | remove   | 抛出异常     | 移出并返回队首 |
    | poll     | 返回 null    | 移出并返回队首 |
    | take     | 阻塞直到返回 | 移出并返回队   |

  - 生产者消费者模式

    生产者消费者模式是多线程编程中非常重要的设计模式，生产者负责生产数据，消费者负责消费数据。生产者消费者模式中间通常还有一个缓冲区，用于存放生产者生产的数据，而消费者则从缓冲区中获取，这样可以降低生产者和消费者之间的耦合度。举个例子来说吧，比如有厂家，代理商，顾客，厂家就是生产者，顾客就是消费者，代理商就是缓冲区，顾客从代理商这里买东西，代理商负责从厂家处拿货，并且销售给顾客，顾客不用直接和厂家打交道，并且通过代理商，就可以直接获取商品，或者从代理商处知道货物不足，需要等待。

  - 线程池

    > 线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。

    由于 Java 创建和销毁线程都会带来资源上的销毁，所以线程池可以帮助我们复用线程，减少资源消耗。

    example:

    > Java 线程池可以通过 Executors 工具类创建，Executors 常用方法：
    >
    > - newFixedThreadPool(int nThreads):创建一个固定大小为 n 的线程池
    > - newSingleThreadExecutor():创建只有一个线程的线程池
    > - newCachedThreadPool():创建一个根据需要创建新线程的线程池
    >
    > ```
    > import java.util.concurrent.ExecutorService;
    > import java.util.concurrent.Executors;
    > 
    > public class ThreadPoolDemo {
    >  //使用Executors 创建一个固定大小为5的线程池
    >  private static ExecutorService executorService = Executors.newFixedThreadPool(5);
    > 
    >  public static void main(String[] args) {
    > //        提交任务
    >      executorService.submit(() -> {
    >          for (int i = 0; i < 10; i++) {
    >              System.out.print(i + " ");
    >          }
    >      });
    >      //停止线程池 并不会立即关闭 ，而是在线程池中的任务执行完毕后才关闭
    >      executorService.shutdown();
    >  }
    > }
    > ```

    > ```
    > public class ThreadPoolDemo2 {
    >  private static ExecutorService executorService = new ThreadPoolExecutor(
    >          5, //核心线程数为5
    >          10,//最大线程数为10
    >          0L, TimeUnit.MILLISECONDS,//非核心线程存活时间
    >          new LinkedBlockingQueue<>());//任务队列 
    > 
    >  public static void main(String[] args) {
    >      //提交任务
    >      executorService.submit(() -> {
    >          for (int i = 0; i < 10; i++) {
    >              System.out.print(i + " ");
    >          }
    >      });
    >      //关闭线程池
    >      executorService.shutdown();
    >  }
    > }
    > ```

  - JDBC

    JDBC 是连接数据库和 Java 程序的桥梁，通过 JDBC API 可以方便地实现对各种主流数据库的操作。

    JDBC 的全称是 Java Database Connectivity，叫做 Java 数据库连接。它包括了一组与数据库交互的api，还有与数据库进行通信的驱动程序。

    我们要写涉及到数据库的程序，是通过 C 语言或者 C++ 语言直接访问数据库的接口,对于不同的数据库，我们需要知道不同数据库对外提供的系统 API，这就影响了我们程序的扩展和跨平台的实现。

    那么有没有一种方法来对不同的数据库接口进行统一呢？当然有。我们只需要和最上层接口进行交互，剩下的部分就交给其他各层去处理，我们的任务就变的轻松简单许多。

    JDBC 为数据库开发人员提供了一个标准的 API，据此可以构建更高级的工具和接口使数据库开发人员能够用纯 Java API 编写数据库应用程序。

  - 数据库

    数据库，简而言之可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的数据运行新增、截取、更新、删除等操作。

    所谓“数据库”系以一定方式储存在一起、能予多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。一个数据库由多个表空间（Tablespace）构成。

  - 关系数据库

    关于关系参见数据结构、离散数学、数据库概论

    常见的关系型数据库有以下几种：

    - MySQL
      - MariaDB
      - Percona Server
    - PostgreSQL
    - Microsoft Access
    - Microsoft SQL Server
    - Google Fusion Tables
    - FileMaker
    - Oracle 数据库
    - Sybase
    - dBASE
    - Clipper
    - FoxPro
    - foshub

    常见非关系数据库：

    - Redis
    - BigTable
    - Cassandra
    - MongoDB
    - CouchDB

  - SQL

    结构化查询语言(Structured Query Language)简称 SQL(发音：/ˈes kjuː ˈel/ "S-Q-L")，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。 结构化查询语言是高级的非过程化编程语言，允许用户在高层数据结构上工作。它不要求用户指定对数据的存放方法，也不需要用户了解具体的数据存放方式，所以具有完全不同底层结构的不同数据库系统, 可以使用相同的结构化查询语言作为数据输入与管理的接口。结构化查询语言语句可以嵌套，这使它具有极大的灵活性和强大的功能。

  - SQL语法

    关于语法详见SQL教程。

    关于数据库表等操作语法在此略过。

    一般数据查询语法：

    > select *
    >
    > from
    >
    > where

  - JDBC连接数据库

    涉及到建立一个 JDBC 连接的编程主要有四个步骤：

    1. 导入 JDBC 驱动： 只有拥有了驱动程序我们才可以注册驱动程序完成连接的其他步骤。
    2. 注册 JDBC 驱动程序：这一步会导致 JVM 加载所需的驱动类实现到内存中，然后才可以实现 JDBC 请求。
    3. 数据库 URL 指定：创建具有正确格式的地址，指向到要连接的数据库。
    4. 创建连接对象：最后，代码调用 DriverManager 对象的 getConnection() 方法来建立实际的数据库连接。

    接下来我们便详细讲解这四步。

    #### 导入 JDBC 驱动

    需要下载对应数据库的 jdbc 驱动，将其导入到项目中，具体的导入方式根据个人的 IDE 确定，本节课程不使用 IDE，直接使用 javac -cp 命令导入包。

    #### 注册 JDBC 驱动程序

    我们在使用驱动程序之前，必须注册你的驱动程序。注册驱动程序的本质就是将我们将要使用的数据库的驱动类文件动态的加载到内存中，然后才能进行数据库。比如我们使用的 Mysql 数据库。我们可以通过以下两种方式来注册我们的驱动程序。

    1、方法1——Class.forName()：

    动态加载一个类最常用的方法是使用 Java 的 Class.forName() 方法，通过使用这个方法来将数据库的驱动类动态加载到内存中，然后我们就可以使用。

    使用 Class.forName() 来注册 Mysql 驱动程序：

    ```
    try {
       Class.forName("com.mysql.jdbc.Driver");
    }
    catch(ClassNotFoundException ex) {
       System.out.println("Error: unable to load driver class!");
       System.exit(1);
    }
    ```

    2、方法 2——DriverManager.registerDriver()：

    ```
       Driver driver = new com.mysql.jdbc.Driver();
       DriverManager.registerDriver(driver);
    ```

    #### 指定数据库连接 URL

    当加载了驱动程序，便可以使用 DriverManager.getConnection() 方法连接到数据库了。

    这里给出 DriverManager.getConnection() 三个重载方法：

    ```
    getConnection(String url)
    
    getConnection(String url, Properties prop)
    
    getConnection(String url, String user, String password)
    ```

    数据库的 URL 是指向数据库地址。下表列出了下来流行的 JDBC 驱动程序名和数据库的 URL。

    | RDBMS  | JDBC 驱动程序的名称             | URL                                                 |
    | ------ | ------------------------------- | --------------------------------------------------- |
    | Mysql  | com.mysql.jdbc.Driver           | jdbc:mysql://hostname/ databaseName                 |
    | Oracle | oracle.jdbc.driver.OracleDriver | jdbc:oracle:thin:@hostname:port Number:databaseName |
    | DB2    | COM.ibm.db2.jdbc.net.DB2Driver  | jdbc:db2:hostname:port Number/databaseName          |
    | Sybase | com.sybase.jdbc.SybDriver       | jdbc:sybase:Tds:hostname: port Number/databaseName  |

    #### 创建连接对象

    下面三种形式 DriverManager.getConnection() 方法来创建一个连接对象，以 Mysql 为例。getConnection()最常用形式要求传递一个数据库 URL，用户名 username 和密码 password。

    1、使用数据库 URL 的用户名和密码

    ```
    String URL = "jdbc:mysql://localhost/EXAMPLE";
    String USER = "username";
    String PASS = "password"
    Connection conn = DriverManager.getConnection(URL, USER, PASS);
    ```

    2、只使用一个数据库 URL

    然而，在这种情况下，数据库的 URL，包括用户名和密码。

    ```
    String URL = "jdbc:mysql://localhost/EXAMPLE?user=root&password=0909";
    //Mysql URL的参数设置详细可以查阅相关资料
    Connection conn = DriverManager.getConnection(URL);
    ```

    3、使用数据库的 URL 和一个 Properties 对象

    ```
    import java.util.*;
    
    String URL = "jdbc:mysql://localhost/EXAMPLE";
    Properties pro = new Properties( );
    
    //Properties对象，保存一组关键字-值对
    pro.put( "user", "root" );
    pro.put( "password", "" );
    
    Connection conn = DriverManager.getConnection(URL, pro);
    ```

    4、关闭 JDBC 连接

    ```
    conn.close();
    ```

  - example

    > ```
    > import java.sql.*;
    > 
    > public class CreateDatabase {
    >     public static void main(String[] args){
    >         Connection connection = null;
    >         try {
    >             //加载数据库驱动
    >             Class.forName("com.mysql.jdbc.Driver");
    >             //打开数据库连接 第一个参数为数据库地址  后面2个参数分别为数据库用户名和密码
    >             connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/","root","");
    >             //创建Statement
    >             Statement statement = connection.createStatement();
    >             //执行sql
    >             statement.execute("create database EXAMPLE");
    >         } catch (ClassNotFoundException e) {
    >             e.printStackTrace();
    >         } catch (SQLException e) {
    >             e.printStackTrace();
    >         }finally {
    >             try {
    >                 //关闭连接
    >                 if (connection != null) {
    >                     connection.close();
    >                 }
    >             } catch (SQLException e) {
    >                 e.printStackTrace();
    >             }
    >         }
    >     }
    > }
    > ```

  - sql操作

    当连接上了数据库后，就需要通过 sql 语句对数据库进行操作。随着 Java 语言应用面的逐步拓宽,Sun 公司开发了一个标准的 SQL 数据库访问接口———JDBC API。它可以使 Java 编程人员通过一个一致的接口,访问多种关系数据库。而今天我们就来学习一下，如何利用 JDBC 的一些核心 API 与数据库进行交互。

    通过使用 JDBC Statement, CallableStatement 和 PreparedStatement 接口定义的方法和属性，使可以使用 SQL 或 PL/SQL 命令和从数据库接收数据。它们还定义了许多方法，帮助消除 Java 和数据库之间数据类型的差异。

    | 接口              | 应用场景                                                     |
    | ----------------- | ------------------------------------------------------------ |
    | Statement         | 当在运行时使用静态 SQL 语句时（Statement 接口不能接收参数）  |
    | CallableStatement | 当要访问数据库中的存储过程时（CallableStatement 对象的接口还可以接收运行时输入参数） |
    | PreparedStatement | 当计划多次使用 SQL 语句时（PreparedStatement 接口接收在运行时输入参数） |

  - statement

    > 使用 Statement 接口，第一步肯定是创建一个 Statement 对象了。我们需要使用 Connection 对象的 createStatement() 方法进行创建。
    >
    > ```
    > Statement stmt = null;
    > try {
    >    stmt = conn.createStatement( );
    >    . . .
    > }
    > catch (SQLException e) {
    >    . . .
    > }
    > finally {
    >    . . .
    > }
    > ```
    >
    > 一旦创建了一个 Statement 对象，我们就可以用它来执行 SQL 语句了，首先我们先来看看 Statement 里面有哪些方法吧！
    >
    > | 方法                               | 说明                                                         |
    > | ---------------------------------- | ------------------------------------------------------------ |
    > | boolean execute(String SQL)        | 如果 ResultSet 对象可以被检索返回布尔值 true，否则返回 false。使用这个方法来执行 SQL DDL 语句，或当需要使用真正的动态 SQL |
    > | int executeUpdate(String SQL)      | 用于执行 INSERT、UPDATE 或 DELETE 语句以及 SQLDDL（数据定义语言）语句。返回值是一个整数，指示受影响的行数（即更新计数） |
    > | ResultSet executeQuery(String SQL) | 返回 ResultSet 对象。用于产生单个结果集的语句，例如 SELECT 语句 |
    >
    > 正如关闭一个 Connection 对象来释放数据库连接资源，出于同样的原因，也应该关闭 Statement 对象。
    >
    > ```
    > Statement stmt = null;
    > try {
    >    stmt = conn.createStatement( );
    >    . . .
    > }
    > catch (SQLException e) {
    >    . . .
    > }
    > finally {
    >    stmt.close();
    > }
    > ```
    >
    > 注：如果关闭了 Connection 对象首先它会关闭 Statement 对象，然而应该始终明确关闭 Statement 对象，以确保正确的清除。

    PreparedStatement 接口扩展了 Statement 接口，有利于高效地执行多次使用的 SQL 语句。

    CallableStatement 对象为所有的 DBMS 提供了一种以标准形式调用存储过程的方法。存储过程储存在数据库中。对储存过程的调用是 CallableStatement 对象所含的内容。三种类型的参数有：IN，OUT 和 INOUT。PreparedStatement 对象只使用IN参数。 CallableStatement 对象可以使用所有三个

    | 参数  | 描述                                                         |
    | ----- | ------------------------------------------------------------ |
    | IN    | 它的值是在创建 SQL 语句时未知的参数，将 IN 参数传给 CallableStatement 对象是通过 setXXX() 方法完成的 |
    | OUT   | 其值由它返回的 SQL 语句提供的参数。从 OUT 参数的 getXXX() 方法检索值 |
    | INOUT | 同时提供输入和输出值的参数，绑定的 setXXX() 方法的变量，并使用 getXXX() 方法检索值 |

  - resultSet

    ResultSet 对象具有指向其当前数据行的光标。最初，光标被置于第一行之前。next 方法将光标移动到下一行；因为该方法在 ResultSet 对象没有下一行时返回 false，所以可以在 while 循环中使用它来迭代结果集。光标可以方便我们对结果集进行遍历。默认的 ResultSet 对象不可更新，仅有一个向前移动的光标。因此，只能迭代它一次，并且只能按从第一行到最后一行的顺序进行。

    ResultSet 接口的方法可分为三类： 　　

    - 导航方法：用于移动光标
    - 获取方法：用于查看当前行的光标所指向的列中的数据
    - 更新方法：用于更新当前行的列中的数据

    JDBC 提供下列连接方法来创建所需的 ResultSet 语句：

    ```
    createStatement(int RSType, int RSConcurrency);
    
    prepareStatement(String SQL, int RSType, int RSConcurrency);
    
    prepareCall(String sql, int RSType, int RSConcurrency);
    ```

    RSType 表示 ResultSet 对象的类型，RSConcurrency 是 ResultSet 常量，用于指定一个结果集是否为只读或可更新。

    ResultSet 的类型，如果不指定 ResultSet 类型，将自动获得一个是 TYPE_FORWARD_ONLY：

    | 类型                              | 描述                                                         |
    | --------------------------------- | ------------------------------------------------------------ |
    | ResultSet.TYPE_FORWARD_ONLY       | 游标只能向前移动的结果集                                     |
    | ResultSet.TYPE_SCROLL_INSENSITIVE | 游标可以向前和向后滚动，但不及时更新，就是如果数据库里的数据修改过，并不在 ResultSet 中反应出来 |
    | ResultSet.TYPE_SCROLL_SENSITIVE   | 游标可以向前和向后滚动，并及时跟踪数据库的更新,以便更改 ResultSet 中的数据 |

    并发性的 ResultSet，如果不指定任何并发类型，将自动获得一个为 CONCUR_READ_ONLY

    | 并发                       | 描述                       |
    | -------------------------- | -------------------------- |
    | ResultSet.CONCUR_READ_ONLY | 创建结果集只读。这是默认的 |
    | ResultSet.CONCUR_UPDATABLE | 创建一个可更新的结果集     |

    如初始化一个 Statement 对象来创建一个双向、可更新的 ResultSet 对象：

    ```
    try {
       Statement stmt = conn.createStatement(
                               ResultSet.TYPE_SCROLL_INSENSITIVE,
                               ResultSet.CONCUR_UPDATABLE);
    }
    catch(Exception ex) {
       ....
    }
    finally {
       ....
    }
    ```

  - JDBC事务

    我们在编写 java 程序的时候，在默认情况下，JDBC 连接是在自动提交模式下，即每个 SQL 语句都是在其完成时提交到数据库。但有时候我们为了提高程序运行的性能或者保持业务流程的完整性，以及使用了分布式事务管理方式，这个时候我们可能想关闭自动提交而自己管理和控制自己的事务。 　　

    让多条 SQL 在一个事务中执行，并且保证这些语句是在同一时间共同执行的时候，我们就应该为这多条语句定义一个事务。一个事务是把单个 SQL 语句或一组 SQL 语句作为一个逻辑单元，并且如果事务中任何语句失败，则整个事务失败。

    如果我们要启动一个事务，而不是让 JDBC 驱动程序默认使用 auto-commit 模式支持。这个时候我们就要使用 Connection 对象的 setAutoCommit() 方法。我们传递一个布尔值 false 到 setAutoCommit() 中，就可以关闭自动提交。反之我们传入一个 true 便将其重新打开。

    例如:

    ```
    Connection conn = null;
    conn = DriverManager.getConnection(URL);
    //关闭自动提交
    conn.setAutoCommit(false);
    ```

    我们关闭了自动提交后，如果我们要提交数据库更改怎么办呢？这时候就要用到我们的提交和回滚了。我们要提交更改，可以调用 commit() 方法:

    ```
    conn.commit();
    ```

    尤其不要忘记，在 catch 块内添加回滚事务，表示操作出现异常，撤销事务：

    ```
    conn.rollback();
    ```

  - 反射

    Java 反射说的是在运行状态中，对于任何一个类，我们都能够知道这个类有哪些方法和属性。对于任何一个对象，我们都能够对它的方法和属性进行调用。我们把这种动态获取对象信息和调用对象方法的功能称之为反射机制。

    反射是 Java 编程语言的一个特性，它提供了在运行时检查和动态调用类、方法、属性的能力。

    反射可以在运行时检查类，接口，方法和变量。还可以实例化对象、调用方法、获取和设置变量值。比如当我们不知道一个类中是否拥有某个方法时，我们就可以使用反射来检查是否拥有这个方法。

    常用类：

    - Class：Class 类表示正在运行的 Java 程序中的类和接口。
    - Field：提供有关类或接口的单个域的信息和动态访问。如数据类型，访问修饰符，域的名称和值。
    - Method：提供有关类或接口上的单个方法的信息和访问权限。如访问修饰符，返回类型，名称，参数类型和方法的异常类型。
    - Constructor：提供有关类的单个构造函数的信息和访问权限。例如构造函数的访问修饰符，名称和参数类型。
    - Modifier：提供了有关访问修饰符的信息。

    **Class：**

    Class 类没有公共构造方法，可以通过以下方法获取 Class 类。

    - Object 提供的 getClass()方法。
    - 类名.Class
    - Class.forName(String className)方法。className 为类的全限定名。

    Class 类常用方法：

    | 方法                                                         | 描述                       |
    | ------------------------------------------------------------ | -------------------------- |
    | Field getField(String name)                                  | 获取指定的域对象           |
    | Field[] getFields()                                          | 返回所有的公有域对象数组   |
    | Method getDeclaredMethod(String name, Class<?>... parameterTypes) | 返回指定的方法对象         |
    | Method[] getMethods()                                        | 返回所有的公有方法对象数组 |
    | Method[] getDeclaredFields()                                 | 返回所有方法对象数组       |
    | String getName()                                             | 获取全限定名               |

    更多方法请查阅[官方文档](https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html)

    example:

    >  package com.ws.ex;
    >
    > import java.lang.reflect.Field;
    > import java.lang.reflect.Method;
    > import java.lang.reflect.Modifier;
    >
    > public class ReflectDemo {
    >     public int a;
    >     private int b;
    >
    > ```
    > public static void main(String[] args) {
    >     Class<ReflectDemo> reflectDemoClass = ReflectDemo.class;
    >     //输出所有的域名称
    >     for (Field declaredField : reflectDemoClass.getDeclaredFields()) {
    >         //可以通过Modifier将具体的权限信息输出，否则只会显示代表权限的数值
    >         System.out.println("域：" + declaredField.getName() + " 修饰符：" + Modifier.toString(declaredField.getModifiers()));
    >     }
    >     //输出所有的公有域名称
    >     for (Field field : reflectDemoClass.getFields()) {
    >         System.out.println("公有域：" + field.getName() + " 修饰符：" + Modifier.toString(field.getModifiers()));
    >     }
    >     //输出类的所有方法名
    >     for (Method declaredMethod : reflectDemoClass.getDeclaredMethods()) {
    >         System.out.println("方法：" + declaredMethod.getName() + " 修饰符：" + Modifier.toString(declaredMethod.getModifiers()));
    >     }
    > }
    > 
    > public void fun1() {
    > }
    > 
    > private void fun2() {
    > }
    > ```
    >
    > }

  - 正则表达式

    > 则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为 regex、regexp 或 RE ），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。

    Java 通过`java.util.regex`包支持正则表达式的的功能。

    匹配：

    > ```
    > import java.util.regex.Matcher;
    > import java.util.regex.Pattern;
    > 
    > public class RegexDemo {
    >     public static void main(String[] args) {
    > //       Pattern类 正则表达式的编译表示。
    >         Pattern pattern = Pattern.compile("^[a-zA-Z0-9_!#$%&'*+/=?`{|}~^.-]+@[a-zA-Z0-9.-]+$");
    >         String[] emails = {"shiyanlou@shiyanlou.com", "shiyanlou"};
    >         for (String email :
    >                 emails) {
    > //Matcher 通过解释Pattern对字符序列执行匹配操作的引擎
    >             Matcher matcher = pattern.matcher(email);
    >             System.out.println(email + "匹配结果：" + matcher.matches());
    >         }
    >     }
    > }
    > ```

  - 设计模式

    我们都站在巨人的肩膀上，设计模式就是程序设计开发过程中后来者学习前辈的成果之一。

    设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。

    换句话说，设计模式是一套被反复使用、多数人知晓的、经过分类的、代码设计的 `经验的总结`。使用设计模式是为了可重用代码，让代码更容易被他人理解，保证代码可靠性。

  - 设计模式设计原则

    **1、开闭原则（Open Close Principle）**

    开闭原则的意思是：`对扩展开放，对修改封闭`。在程序需要进行扩展的时候，不能去修改或影响原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性更好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。

    **2、里氏代换原则（Liskov Substitution Principle）**

    里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。里氏代换原则是继承复用的基石，只有当子类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而且子类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

    **3、依赖倒转原则（Dependence Inversion Principle）**

    这个原则是开闭原则的基础，核心内容：针对接口编程，高层模块不应该依赖底层模块，二者都应该依赖抽象而不依赖于具体。

    **4、接口隔离原则（Interface Segregation Principle）**

    这个原则的意思是：使用多个隔离的接口，比使用单个庞大的接口要好。其目的在于降低耦合度。由此可见，其实设计模式就是从大型软件架构出发，便于升级和维护软件的设计思想。它强调低依赖、低耦合。

    **5、单一职责原则（Single Responsibility Principle）**

    类的职责要单一，不能将太多的职责放在一个类中。

    可能有的人会觉得单一职责原则和前面的接口隔离原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要约束的是类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口，主要针对抽象，针对程序整体框架的构建。

    **6、最少知道原则（Demeter Principle）**

    最少知道原则也叫迪米特法则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。

    一个对象应该对其他对象保持最少的了解。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。所以在类的设计上，每一个类都应当尽量降低成员的访问权限。

    **7、合成复用原则（Composite Reuse Principle）**

    合成复用原则就是在一个新的对象里通过关联关系（组合关系、聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简而言之，尽量多使用 组合/聚合 的方式，尽量少使用甚至不使用继承关系。

    现在大概有23种设计模式，常用的有工厂模式、单例模式、适配器模式、观察者模式等等。

  - 单例模式

    单例模式（Singleton Pattern），顾名思义，就是被单例的对象只能有一个实例存在。单例模式的实现方式是，一个类能返回对象的一个引用（永远是同一个）和一个获得该唯一实例的方法（必须是静态方法）。通过单例模式，我们可以保证系统中只有一个实例，从而在某些特定的场合下达到节约或者控制系统资源的目的。

    在 【装饰者模式】中，我们体验了拥有各种不同特性的女朋友的 “酸爽”... 不过梦想很丰满，现实很骨感，最后你只能拥有一个老婆。

  - 单例example

    1、饿汉模式

    > ```
    > package com.ws.design.pattern.single;
    > 
    > public class Wife01 {
    >     //一开始就创建一个实例
    >     private static final Wife01 wife01 = new Wife01();
    > 
    >     private Wife01(){}
    >     public static Wife01 getInstance(){
    >         return wife01;
    >     }
    > }
    > ```

    2、懒汉模式

    > ```
    > package com.ws.design.pattern.single;
    > 
    > public class Wife02 {
    >     private static Wife02 wife02;
    >     private Wife02(){}
    >     public static Wife02 getInstance(){
    >         if (wife02 == null){
    >             wife02 = new Wife02();
    >         }
    >         return wife02;
    >     }
    > }
    > ```

    3、线程安全的懒汉模式

    > ```
    > package com.ws.design.pattern.single;
    > 
    > public class Wife03 {
    >     private static Wife03 wife03;
    >     private Wife03(){};
    >     public static synchronized Wife03 getInstance(){
    >         if (wife03 == null){
    >             wife03 = new Wife03();
    >         }
    >         return wife03;
    >     }
    > }
    > ```

    4、双重检验锁

    > ```
    > package com.ws.design.pattern.single;
    > 
    > public class Wife04 {
    >     private volatile static Wife04 wife04;
    >     private  Wife04(){}
    > 
    >     public static Wife04 getInstance(){
    >         if (wife04 == null){
    >             synchronized(Wife04.class){
    >                 if (wife04 == null){
    >                     wife04 = new Wife04();
    >                 }
    >             }
    >         }
    >         return  wife04;
    >     }
    > }
    > ```

    5、静态内部类

    > ```
    > package com.ws.design.pattern.single;
    > 
    > public class Wife05 {
    >     private static class WifeHolder{
    >         private static final Wife05 wife05 = new Wife05();
    >     }
    > 
    >     private Wife05(){}
    >     public static Wife05 getInstance(){
    >         return WifeHolder.wife05;
    >     }
    > }
    > ```

    6、枚举

    > package com.ws.design.pattern.single;
    >
    > public enum Wife {
    >     INSTANCE;
    >     public void whateverMethod(){}
    > }

- network

2.学习心得   

```
+ 实践出真知、不手动操作几次是难以掌握
+ 断章取义难理解
+ 心急吃不得热豆腐
+ 总结归纳很重要
+ 工欲善其事、必先利其器
```



## 明日学习计划

------

- linux学习

  复习总结、日志

- java

- 设计模式

- GO

  协程、通道实战

- network



## 截图

| [ ..](https://github.com/inspurcloudgroup/icprd1/tree/master/吴帅/learn_pic) |                                                              |                                                              |                |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------- |
|                                                              | [JDBC01.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0608/JDBC01.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/a56369961e6356875c9e5eb2c11c1f671f329cac) | 19 seconds ago |
|                                                              | [JDBC02.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0608/JDBC02.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/a56369961e6356875c9e5eb2c11c1f671f329cac) | 19 seconds ago |
|                                                              | [java01.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0608/java01.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/a56369961e6356875c9e5eb2c11c1f671f329cac) | 19 seconds ago |
|                                                              | [java02.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0608/java02.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/a56369961e6356875c9e5eb2c11c1f671f329cac) | 19 seconds ago |
|                                                              | [java03.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0608/java03.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/a56369961e6356875c9e5eb2c11c1f671f329cac) | 19 seconds ago |
|                                                              | [java04.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0608/java04.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/a56369961e6356875c9e5eb2c11c1f671f329cac) | 19 seconds ago |
|                                                              | [os01.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0608/os01.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/f52e261b7330573bc38ca54283451a36ebd0a0e2) | 5 hours ago    |
|                                                              | [os02.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0608/os02.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/f52e261b7330573bc38ca54283451a36ebd0a0e2) | 5 hours ago    |
|                                                              | [os03.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0608/os03.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/f52e261b7330573bc38ca54283451a36ebd0a0e2) | 5 hours ago    |
|                                                              | [os04.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0608/os04.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/f52e261b7330573bc38ca54283451a36ebd0a0e2) | 5 hours ago    |
|                                                              | [os05.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0608/os05.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/f52e261b7330573bc38ca54283451a36ebd0a0e2) | 5 hours ago    |
|                                                              | [os06.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0608/os06.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/f52e261b7330573bc38ca54283451a36ebd0a0e2) | 5 hours ago    |
|                                                              | [os07.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0608/os07.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/f52e261b7330573bc38ca54283451a36ebd0a0e2) | 5 hours ago    |
|                                                              | [os08.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0608/os08.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/f52e261b7330573bc38ca54283451a36ebd0a0e2) | 5 hours ago    |
|                                                              | [os09.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0608/os09.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/f52e261b7330573bc38ca54283451a36ebd0a0e2) | 5 hours ago    |
|                                                              | [os10.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0608/os10.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/f52e261b7330573bc38ca54283451a36ebd0a0e2) | 5 hours ago    |
|                                                              | [os11.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0608/os11.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/f52e261b7330573bc38ca54283451a36ebd0a0e2) | 5 hours ago    |
|                                                              | [os12.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0608/os12.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/f52e261b7330573bc38ca54283451a36ebd0a0e2) | 5 hours ago    |
|                                                              | [os13.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0608/os13.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/f52e261b7330573bc38ca54283451a36ebd0a0e2) | 5 hours ago    |
|                                                              | [os14.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0608/os14.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/f52e261b7330573bc38ca54283451a36ebd0a0e2) | 5 hours ago    |
|                                                              | [os15.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0608/os15.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/f52e261b7330573bc38ca54283451a36ebd0a0e2) | 5 hours ago    |
|                                                              | [os16.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0608/os16.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/f52e261b7330573bc38ca54283451a36ebd0a0e2) | 5 hours ago    |
|                                                              | [os17.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0608/os17.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/f52e261b7330573bc38ca54283451a36ebd0a0e2) | 5 hours ago    |
|                                                              | [os18.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0608/os18.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/f52e261b7330573bc38ca54283451a36ebd0a0e2) | 5 hours ago    |
|                                                              | [os19.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0608/os19.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/f52e261b7330573bc38ca54283451a36ebd0a0e2) | 5 hours ago    |
|                                                              | [os20.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0608/os20.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/f52e261b7330573bc38ca54283451a36ebd0a0e2) | 5 hours ago    |
