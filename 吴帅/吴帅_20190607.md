```
                             学习总结
```

------



## 今日学习内容

1.学习项目    

- linux

  - 程序与进程

    > **程序**（procedure）：不太精确地说，程序就是执行一系列有逻辑、有顺序结构的指令，帮我们达成某个结果。就如我们去餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，最后我们得到了这么一盘牛肉盖浇饭。它需要去执行，不然它就像一本武功秘籍，放在那里等人翻看。

    > **进程**（process）：进程是程序在一个数据集合上的一次执行过程，在早期的UNIX、Linux 2.4及更早的版本中，它是系统进行资源分配和调度的独立基本单位。同上一个例子，就如我们去了餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，而里面做饭的是一个进程，做牛肉汤汁的是一个进程，把牛肉汤汁与饭混合在一起的是一个进程，把饭端上桌的是一个进程。它就像是我们在看武功秘籍这么一个过程，然后一个篇章一个篇章地去练。

    程序只是一些列指令的集合，是一个静止的实体，而进程不同，进程有以下的特性：

    - 动态性：进程的实质是一次程序执行的过程，有创建、撤销等状态的变化。而程序是一个静态的实体。
    - 并发性：进程可以做到在一个时间段内，有多个程序在运行中。程序只是静态的实体，所以不存在并发性。
    - 独立性：进程可以独立分配资源，独立接受调度，独立地运行。
    - 异步性：进程以不可预知的速度向前推进。
    - 结构性：进程拥有代码段、数据段、PCB（进程控制块，进程存在的唯一标志）。也正是因为有结构性，进程才可以做到独立地运行。

    > **并发：**在一个时间段内，宏观来看有多个程序都在活动，有条不紊的执行（每一瞬间只有一个在执行，只是在一段时间有多个程序都执行过）

    > **并行：**在每一个瞬间，都有多个程序都在同时执行，这个必须有多个 CPU 才行

    

    > **线程**（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率。

  - 进程分类

    进程可以从两个角度来分类：

    - 以进程的功能与服务的对象来分；
    - 以应用程序的服务类型来分；

  - 进程的衍生

    进程生进程，父亲和儿子的关系。

    我们启动了终端，就是启动了一个 bash 进程，我们可以在 bash 中再输入 bash 则会再启动一个 bash 的进程，此时第二个 bash 进程就是由第一个 bash 进程创建出来的，他们之间又是个什么关系？

    我们一般称呼第一个 bash 进程是第二 bash 进程的父进程，第二 bash 进程是第一个 bash 进程的子进。

  - 进程组和sessions

    每一个进程都会是一个进程组的成员，而且这个进程组是唯一存在的，他们是依靠 PGID（process group ID）来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。

    一般情况，进程组的 PGID 等同于进程组的第一个成员的 PID，并且这样的进程称为该进程组的领导者,也就是领导进程，进程一般通过使用 `getpgrp()` 系统调用来寻找其所在组的 PGID，领导进程可以先终结，此时进程组依然存在，并持有相同的PGID，直到进程组中最后一个进程终结。

    与进程组类似，每当一个进程被创建的时候，它便会成为其父进程所在 Session 中的一员，每一个进程组都会在一个 Session 中，并且这个 Session 是唯一存在的，

    Session 主要是针对一个 tty 建立，Session 中的每个进程都称为一个工作(job)。每个会话可以连接一个终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。Session 意义在于将多个 jobs 囊括在一个终端，并取其中的一个 job 作为前台，来直接接收该终端的输入输出以及终端信号。 其他 jobs 在后台运行。

    > **前台**（foreground）就是在终端中运行，能与你有交互的

    > **后台**（background）就是在终端中运行，但是你并不能与其任何的交互，也不会显示其执行的过程

  - 工作管理

    bash(Bourne-Again shell)支持工作控制（job control）,而 sh（Bourne shell）并不支持。

    并且每个终端或者说 bash 只能管理当前终端中的 job，不能管理其他终端中的 job。比如我当前存在两个 bash 分别为 bash1、bash2，bash1 只能管理其自己里面的 job 并不能管理 bash2 里面的 job

    我们都知道当一个进程在前台运作时我们可以用 `ctrl + c` 来终止它，但是若是在后台的话就不行了。

    我们可以通过 `&` 这个符号，让我们的命令在后台中运行。

    > ls &

    图中所显示的 `[1] 236`分别是该 job 的 job number 与该进程的 PID，而最后一行的 Done 表示该命令已经在后台执行完毕。

    我们还可以通过 `ctrl + z` 使我们的当前工作停止并丢到后台中去

    > Ctrl z

    > bg 
    >
    > fg   后台转前台
    >
    > jobs  查看进程

    既然有方法将被放置在后台的工作提至前台或者让它从停止变成继续运行在后台，当然也有方法删除一个工作，或者重启等等

    ```
    #kill的使用格式如下
    kill -signal %jobnumber
    
    #signal从1-64个信号值可以选择，可以这样查看
    kill －l
    ```

    其中常用的有这些信号值

    | 信号值 | 作用                            |
    | ------ | ------------------------------- |
    | -1     | 重新读取参数运行，类似与restart |
    | -2     | 如同 ctrl+c 的操作退出          |
    | -9     | 强制终止该任务                  |
    | -15    | 正常的方式终止该任务            |

- go

  - 时间

    go提供了强大的支持：时间和时间段。

    请研究time包

    这里面时间它是关联位置的，所以一个重要参数时区time.UTC是必须的。

    提供能一些近乎自然语言的函数：

    比较时间：.Before(now)\After(now)\Equal(now)

    > ```
    > package ex
    > 
    > import "fmt"
    > import "time"
    > 
    > func TimeTest() {
    > p := fmt.Println
    > 
    > // 得到当前时间。
    > now := time.Now()
    > p(now)
    > 
    > // 通过提供年月日等信息，你可以构建一个 `time`。时间总
    > // 是关联着位置信息，例如时区。
    > then := time.Date(
    >    2009, 11, 17, 20, 34, 58, 651387237, time.UTC)
    > p(then)
    > 
    > // 你可以提取出时间的各个组成部分。
    > p(then.Year())
    > p(then.Month())
    > p(then.Day())
    > p(then.Hour())
    > p(then.Minute())
    > p(then.Second())
    > p(then.Nanosecond())
    > p(then.Location())
    > 
    > // 输出是星期一到日的 `Weekday` 也是支持的。
    > p(then.Weekday())
    > 
    > // 这些方法来比较两个时间，分别测试一下是否是之前，
    > // 之后或者是同一时刻，精确到秒。
    > p(then.Before(now))
    > p(then.After(now))
    > p(then.Equal(now))
    > 
    > // 方法 `Sub` 返回一个 `Duration` 来表示两个时间点的间
    > // 隔时间。
    > diff := now.Sub(then)
    > p(diff)
    > 
    > // 我们计算出不同单位下的时间长度值。
    > p(diff.Hours())
    > p(diff.Minutes())
    > p(diff.Seconds())
    > p(diff.Nanoseconds())
    > 
    > // 你可以使用 `Add` 将时间后移一个时间间隔，或者使
    > // 用一个 `-` 来将时间前移一个时间间隔。
    > p(then.Add(diff))
    > p(then.Add(-diff))
    > }
    > ```

  - 时间戳

    获取unix时间的秒数、毫秒数、微秒数。go time都能实现

    > ```
    > 
    > ```

> package ex
>
> import "fmt"
> import "time"
>
> func TimeStamp() {
>
> // 分别使用带 `Unix` 或者 `UnixNano` 的 `time.Now`
> // 来获取从自[协调世界时](http://zh.wikipedia.org/wiki/%E5%8D%94%E8%AA%BF%E4%B8%96%E7%95%8C%E6%99%82)
> // 起到现在的秒数或者纳秒数。
> now := time.Now()
> secs := now.Unix()
> nanos := now.UnixNano()
> fmt.Println(now)
>
> // 注意 `UnixMillis` 是不存在的，所以要得到毫秒数的话，
> // 你要自己手动的从纳秒转化一下。
> millis := nanos / 1000000
> fmt.Println(secs)
> fmt.Println(millis)
> fmt.Println(nanos)
>
> // 你也可以将协调世界时起的整数秒或者纳秒转化到相应的时间。
> fmt.Println(time.Unix(secs, 0))
> fmt.Println(time.Unix(0, nanos))
> }
>
> ```
> 
> ```

- 时间格式化和解析

  Go支持通过基于描述模板的时间格式化和解析。

  > package ex
  >
  > import "fmt"
  > import "time"
  >
  > func TimeFormat() {
  > 	p := fmt.Println
  >
  > ```
  > // 这里是一个基本的按照 RFC3339 进行格式化的例子，使用
  > // 对应模式常量。
  > t := time.Now()
  > p(t.Format(time.RFC3339))
  > 
  > // 时间解析使用同 `Format` 相同的形式值。
  > t1, e := time.Parse(
  > 	time.RFC3339,
  > 	"2012-11-01T22:08:41+00:00")
  > p(t1)
  > 
  > // `Format` 和 `Parse` 使用基于例子的形式来决定日期格式，
  > // 一般你只要使用 `time` 包中提供的模式常量就行了，但是你
  > // 也可以实现自定义模式。模式必须使用时间 `Mon Jan 2 15:04:05 MST 2006`
  > // 来指定给定时间/字符串的格式化/解析方式。时间一定要按照
  > // 如下所示：2006为年，15 为小时，Monday 代表星期几，等等。
  > p(t.Format("3:04PM"))
  > p(t.Format("Mon Jan _2 15:04:05 2006"))
  > p(t.Format("2006-01-02T15:04:05.999999-07:00"))
  > form := "3 04 PM"
  > t2, e := time.Parse(form, "8 41 PM")
  > p(t2)
  > 
  > // 对于纯数字表示的时间，你也可以使用标准的格式化字
  > // 符串来提出出时间值得组成。
  > fmt.Printf("%d-%02d-%02dT%02d:%02d:%02d-00:00\n",
  > 	t.Year(), t.Month(), t.Day(),
  > 	t.Hour(), t.Minute(), t.Second())
  > 
  > // `Parse` 函数在输入的时间格式不正确是会返回一个
  > // 错误。
  > ansic := "Mon Jan _2 15:04:05 2006"
  > _, e = time.Parse(ansic, "8:41PM")
  > p(e)
  > ```
  >
  > }

- 随机数

  Go 的 `math/rand` 包提供了[伪随机数生成器（英）](http://en.wikipedia.org/wiki/Pseudorandom_number_generator)。

  > package ex
  >
  > import "fmt"
  > import "math/rand"
  >
  > func RandTest() {
  >
  > ```
  > // 例如，`rand.Intn` 返回一个随机的整数 n，`0 <= n <= 100`。
  > fmt.Print(rand.Intn(100), ",")
  > fmt.Print(rand.Intn(100))
  > fmt.Println()
  > 
  > // `rand.Float64` 返回一个64位浮点数 `f`，
  > // `0.0 <= f <= 1.0`。
  > fmt.Println(rand.Float64())
  > 
  > // 这个技巧可以用来生成其他范围的随机浮点数，例如
  > // `5.0 <= f <= 10.0`
  > fmt.Print((rand.Float64()*5)+5, ",")
  > fmt.Print((rand.Float64() * 5) + 5)
  > fmt.Println()
  > 
  > // 要让伪随机数生成器有确定性，可以给它一个明确的种子。
  > s1 := rand.NewSource(42)
  > r1 := rand.New(s1)
  > 
  > // 调用上面返回的 `rand.Source` 的函数和调用 `rand` 包中函数
  > // 是相同的。
  > fmt.Print(r1.Intn(100), ",")
  > fmt.Print(r1.Intn(100))
  > fmt.Println()
  > ```

> // 如果使用相同的种子生成的随机数生成器，将会产生相同的随机
> 	// 数序列。
> 	s2 := rand.NewSource(42)
> 	r2 := rand.New(s2)
> 	fmt.Print(r2.Intn(100), ",")
> 	fmt.Print(r2.Intn(100))
> 	fmt.Println()
> }

- 数字解析

  在字符串中解析数字，go的strconv包提供了数字解析功能

  > package ex
  >
  > // 内置的 `strconv` 包提供了数字解析功能。
  > import "strconv"
  > import "fmt"
  >
  > func DigitalAnalysis() {
  >
  > ```
  > // 使用 `ParseFloat` 解析浮点数，这里的 `64` 表示表示解
  > // 析的数的位数。
  > f, _ := strconv.ParseFloat("1.234", 64)
  > fmt.Println(f)
  > 
  > // 在使用 `ParseInt` 解析整形数时，例子中的参数 `0` 表
  > // 示自动推断字符串所表示的数字的进制。`64` 表示返回的
  > // 整形数是以 64 位存储的。
  > i, _ := strconv.ParseInt("123", 0, 64)
  > fmt.Println(i)
  > 
  > // `ParseInt` 会自动识别出十六进制数。
  > d, _ := strconv.ParseInt("0x1c8", 0, 64)
  > fmt.Println(d)
  > 
  > // `ParseUint` 也是可用的。
  > u, _ := strconv.ParseUint("789", 0, 64)
  > fmt.Println(u)
  > 
  > // `Atoi` 是一个基础的 10 进制整型数转换函数。
  > k, _ := strconv.Atoi("135")
  > fmt.Println(k)
  > 
  > // 在输入错误时，解析函数会返回一个错误。
  > _, e := strconv.Atoi("wat")
  > fmt.Println(e)
  > ```
  >
  > }

- URL

  URL提供统一资源定位方式。go提供net/url 支持

  > ```
  > package ex
  > 
  > import (
  > "fmt"
  > "net/url"
  > "strings"
  > )
  > 
  > func UrlTest() {
  > 
  > // 我们将解析这个 URL 示例，它包含了一个 scheme，
  > // 认证信息，主机名，端口，路径，查询参数和片段。
  > s := "postgres://user:pass@host.com:5432/path?k=v#f"
  > 
  > // 解析这个 URL 并确保解析没有出错。
  > u, err := url.Parse(s)
  > if err != nil {
  >    panic(err)
  > }
  > 
  > // 直接访问 scheme。
  > fmt.Println(u.Scheme)
  > 
  > // `User` 包含了所有的认证信息，这里调用 `Username`
  > // 和 `Password` 来获取独立值。
  > fmt.Println(u.User)
  > fmt.Println(u.User.Username())
  > p, _ := u.User.Password()
  > fmt.Println(p)
  > 
  > // `Host` 同时包括主机名和端口信息，如过端口存在的话，
  > // 使用 `strings.Split()` 从 `Host` 中手动提取端口。
  > fmt.Println(u.Host)
  > h := strings.Split(u.Host, ":")
  > fmt.Println(h[0])
  > fmt.Println(h[1])
  > 
  > // 这里我们提出路径和查询片段信息。
  > fmt.Println(u.Path)
  > fmt.Println(u.Fragment)
  > 
  > // 要得到字符串中的 `k=v` 这种格式的查询参数，可以使
  > // 用 `RawQuery` 函数。你也可以将查询参数解析为一个
  > // map。已解析的查询参数 map 以查询字符串为键，对应
  > // 值字符串切片为值，所以如何只想得到一个键对应的第
  > // 一个值，将索引位置设置为 `[0]` 就行了。
  > fmt.Println(u.RawQuery)
  > m, _ := url.ParseQuery(u.RawQuery)
  > fmt.Println(m)
  > fmt.Println(m["k"][0])
  > }
  > ```

- SHA1散列

  [*SHA1 散列*](http://en.wikipedia.org/wiki/SHA-1)经常用生成二进制文件或者文本块的短标识。例如，[git 版本控制系统](http://git-scm.com/)大量的使用 SHA1 来标识受版本控制的文件和目录。那么 Go 中如何进行 SHA1 散列计算？

  例子：

  > ```
  > package hash01
  > 
  > import (
  > "crypto/sha1"
  > "fmt"
  > )
  > 
  > // Go 在多个 `crypto/*` 包中实现了一系列散列函数。
  > func Sha1() {
  > s := "sha1 this string"
  > 
  > // 产生一个散列值得方式是 `sha1.New()`，`sha1.Write(bytes)`，
  > // 然后 `sha1.Sum([]byte{})`。这里我们从一个新的散列开始。
  > h := sha1.New()
  > 
  > // 写入要处理的字节。如果是一个字符串，需要使用
  > // `[]byte(s)` 来强制转换成字节数组。
  > h.Write([]byte(s))
  > 
  > // 这个用来得到最终的散列值的字符切片。`Sum` 的参数可以
  > // 用来都现有的字符切片追加额外的字节切片：一般不需要要。
  > bs := h.Sum(nil)
  > 
  > // SHA1 值经常以 16 进制输出，例如在 git commit 中。使用
  > // `%x` 来将散列结果格式化为 16 进制字符串。
  > fmt.Println(s)
  > fmt.Printf("%x\n", bs)
  > }
  > ```

  还有其他的散列方式请学习cryto包

- base64 编码

  go提供内建的base64编解码支持

  > ```
  > package ex
  > 
  > // 这个语法引入了 `encoding/base64` 包并使用名称 `b64`
  > // 代替默认的 `base64`。这样可以节省点空间。
  > import b64 "encoding/base64"
  > import "fmt"
  > 
  > func Base64() {
  > 
  > // 这是将要编解码的字符串。
  > data := "abc123!?$*&()'-=@~"
  > 
  > // Go 同时支持标准的和 URL 兼容的 base64 格式。编码需要
  > // 使用 `[]byte` 类型的参数，所以要将字符串转成此类型。
  > sEnc := b64.StdEncoding.EncodeToString([]byte(data))
  > fmt.Println(sEnc)
  > 
  > // 解码可能会返回错误，如果不确定输入信息格式是否正确，
  > // 那么，你就需要进行错误检查了。
  > sDec, _ := b64.StdEncoding.DecodeString(sEnc)
  > fmt.Println(string(sDec))
  > fmt.Println()
  > 
  > // 使用 URL 兼容的 base64 格式进行编解码。
  > uEnc := b64.URLEncoding.EncodeToString([]byte(data))
  > fmt.Println(uEnc)
  > uDec, _ := b64.URLEncoding.DecodeString(uEnc)
  > fmt.Println(string(uDec))
  > }
  > ```

  标准 base64 编码和 URL 兼容 base64 编码的编码字符串存在稍许不同（后缀为 `+` 和 `-`），但是两者都可以正确解码为原始字符串。

- 文件操作

  文件操作在编程里面很常见，go语言也一样。

- 读文件

  > ```
  > package ex
  > 
  > import (
  > "bufio"
  > "fmt"
  > "io"
  > "io/ioutil"
  > "os"
  > )
  > 
  > // 读取文件需要经常进行错误检查，这个帮助方法可以精简下面
  > // 的错误检查过程。
  > func check(e error) {
  > if e != nil {
  >    panic(e)
  > }
  > }
  > 
  > func ReadF() {
  > 
  > // 也许大部分基本的文件读取任务是将文件内容读取到
  > // 内存中。
  > dat, err := ioutil.ReadFile("hello.text")
  > check(err)
  > fmt.Print(string(dat))
  > 
  > // 你经常会想对于一个文件是怎么读并且读取到哪一部分
  > // 进行更多的控制。对于这个任务，从使用 `os.Open`
  > // 打开一个文件获取一个 `os.File` 值开始。
  > f, err := os.Open("hello.text")
  > check(err)
  > 
  > // 从文件开始位置读取一些字节。这里最多读取 5 个字
  > // 节，并且这也是我们实际读取的字节数。
  > b1 := make([]byte, 5)
  > n1, err := f.Read(b1)
  > check(err)
  > fmt.Printf("%d bytes: %s\n", n1, string(b1))
  > 
  > // 你也可以 `Seek` 到一个文件中已知的位置并从这个位置开
  > // 始进行读取。
  > o2, err := f.Seek(6, 0)
  > check(err)
  > b2 := make([]byte, 2)
  > n2, err := f.Read(b2)
  > check(err)
  > fmt.Printf("%d bytes @ %d: %s\n", n2, o2, string(b2))
  > 
  > // `io` 包提供了一些可以帮助我们进行文件读取的函数。
  > // 例如，上面的读取可以使用 `ReadAtLeast` 得到一个更
  > // 健壮的实现。
  > o3, err := f.Seek(6, 0)
  > check(err)
  > b3 := make([]byte, 2)
  > n3, err := io.ReadAtLeast(f, b3, 2)
  > check(err)
  > fmt.Printf("%d bytes @ %d: %s\n", n3, o3, string(b3))
  > 
  > // 没有内置的回转支持，但是使用 `Seek(0, 0)` 实现。
  > _, err = f.Seek(0, 0)
  > check(err)
  > 
  > // `bufio` 包实现了带缓冲的读取，这不仅对有很多小的读
  > // 取操作的能提升性能，也提供了很多附加的读取函数。
  > r4 := bufio.NewReader(f)
  > b4, err := r4.Peek(5)
  > check(err)
  > fmt.Printf("5 bytes: %s\n", string(b4))
  > 
  > // 任务结束后要关闭这个文件（通常这个操作应该在 `Open`
  > // 操作后立即使用 `defer` 来完成）。
  > f.Close()
  > 
  > }
  > ```

- 写文件

  > ```
  > package ex
  > 
  > import (
  > "bufio"
  > "fmt"
  > "io/ioutil"
  > "os"
  > )
  > //
  > //func check(e error) {
  > // if e != nil {
  > //    panic(e)
  > // }
  > //}
  > 
  > func main() {
  > 
  > // 开始，这里是展示如写入一个字符串（或者只是一些
  > // 字节）到一个文件。
  > d1 := []byte("hello\nworld\n")
  > err := ioutil.WriteFile("/tmp/dat1", d1, 0644)
  > check(err)
  > 
  > // 对于更细粒度的写入，先打开一个文件。
  > f, err := os.Create("/tmp/dat2")
  > check(err)
  > 
  > // 打开文件后，习惯立即使用 defer 调用文件的 `Close`
  > // 操作。
  > defer f.Close()
  > 
  > // 你可以写入你想写入的字节切片
  > d2 := []byte{115, 111, 109, 101, 10}
  > n2, err := f.Write(d2)
  > check(err)
  > fmt.Printf("wrote %d bytes\n", n2)
  > 
  > // `WriteString` 也是可用的。
  > n3, err := f.WriteString("writes\n")
  > fmt.Printf("wrote %d bytes\n", n3)
  > 
  > // 调用 `Sync` 来将缓冲区的信息写入磁盘。
  > f.Sync()
  > 
  > // `bufio` 提供了和我们前面看到的带缓冲的读取器一
  > // 样的带缓冲的写入器。
  > w := bufio.NewWriter(f)
  > n4, err := w.WriteString("buffered\n")
  > fmt.Printf("wrote %d bytes\n", n4)
  > 
  > // 使用 `Flush` 来确保所有缓存的操作已写入底层写入器。
  > w.Flush()
  > 
  > }
  > ```

- 行过滤器

  一个*行过滤器* 在读取标准输入流的输入，处理该输入，然后将得到一些的结果输出到标准输出的程序中是常见的一个功能。`grep` 和 `sed` 是常见的行过滤器。

  > package ex
  >
  > import (
  > "bufio"
  > "fmt"
  > "os"
  > "strings"
  > )
  >
  > func FilterTest() {
  >
  > ```
  > // 对 `os.Stdin` 使用一个带缓冲的 scanner，让我们可以
  > // 直接使用方便的 `Scan` 方法来直接读取一行，每次调用
  > // 该方法可以让 scanner 读取下一行。
  > scanner := bufio.NewScanner(os.Stdin)
  > 
  > for scanner.Scan() {
  > 	// `Text` 返回当前的 token，现在是输入的下一行。
  > 	ucl := strings.ToUpper(scanner.Text())
  > 
  > 	// 写出大写的行。
  > 	fmt.Println(ucl)
  > }
  > 
  > // 检查 `Scan` 的错误。文件结束符是可以接受的，并且
  > // 不会被 `Scan` 当作一个错误。
  > if err := scanner.Err(); err != nil {
  > 	fmt.Fprintln(os.Stderr, "error:", err)
  > 	os.Exit(1)
  > }
  > ```
  >
  > }

- java

  - java面向对象

    包含类、对象、构造方法、引用和对象实例、封装、多态、继承、抽象、抽象类、接口、内部类、方法的重写和重载。

    几句话：

    万物皆是对象，属性和动作的结合体

    对象的集合，一类对象：人、动物

    关于类中变量：局部变量（函数）、成员变量、类变量（静态变量static）

    每个类都有构造方法、这new时被调用、没有定义、编译器提供。

    构造方法名必须与类名相同、一个类可以有多个构造方法

    所有类都继承Object

    - 静态变量

      #### 静态成员

      Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问

    - 静态方法

      `final`关键字可以修饰类、方法、属性和变量

      1. final 修饰类，则该类不允许被继承，为最终类
      2. final 修饰方法，则该方法不允许被覆盖（重写）
      3. final 修饰属性：则该类的属性不会进行隐式的初始化（类的初始化属性必须有值）或在构造方法中赋值（但只能选其一）

    - 权限修饰符

    访问权限控制：指的是本类及本类内部的成员（成员变量、成员方法、内部类）对其他类的可见性，即这些内容是否允许其他类访问。

    Java 中一共有四种访问权限控制，其权限控制的大小情况是这样的：public > protected > default(包访问权限) > private 

    | 访问权限  | 本类 | 本包的类 | 子类 | 非子类的外包类 |
    | --------- | ---- | -------- | ---- | -------------- |
    | public    | 是   | 是       | 是   | 是             |
    | protected | 是   | 是       | 是   | 否             |
    | default   | 是   | 是       | 否   | 否             |
    | private   | 是   | 否       | 否   | 否             |

    java默认访问权限

    1、类中的方法：

    不加任何访问权限限定的成员采用的是默认的访问权限，成为default或package。default权限意味着可以被这个类本身和同一个包中的类访问，在其他包中定义的类，即使是这个类的子类，也不能直接访问这个成员。这种访问权限相当于把同一个包中的类作为可信的朋友，如果不加任何访问权限也是default访问，除了这个类本身和同一个包中的类之外，其他类不能生成该类的实例。

     

    2、类

    类的默认访问权限是包级的（如果声明是public的，则所有类都是可以访问的）。所谓的访问就是可以实例化该类。一旦这个类被定义为default访问权限，这在不同包中一旦出现这个类的名字，编译器都会报错。

    （1）每个编译单元（类文件）都仅能有一个public class

    （2）public class的名称（包含大小写）必须和其类文件同名

    （3）一个类文件（*.java）中可以不存在public class

    详细说明：

    1、**public：** 所修饰的类、变量、方法，在内外包均具有访问权限；
    2、**protected：** 这种权限是为继承而设计的，protected所修饰的成员，对所有子类是可访问的，但只对同包的类是可访问的，对外包的非子类是不可以访问；
    3、**包访问权限（default）：** 只对同包的类具有访问的权限，外包的所有类都不能访问；
    4、**private：** 私有的权限，只对本类的方法可以使用；

    **注意：** 要区分开 protected 权限、包访问权限，正确使用它们；

    - 当某个成员能被所有的子类继承，但不能被外包的非子类访问，就是用protected；
    - 当某个成员的访问权限只对同包的类开放，包括不能让外包的类继承这个成员，就用包访问权限；

    使用访问权限控制的原因：

    1）使用户不要碰触那些他们不该碰触的部分；
    2）类库设计者可以更改类的内部工作的方式，而不会担心这样会对用户产生重大影响；

    访问权限控制的使用场景

    访问权限使用的场景可以总结为下面的五种场景，分别对访问权限的使用有不同的限制：

    外部类的访问控制

    **外部类（外部接口）** 是相对于内部类（也称为嵌套类）、内部接口而言的。外部类的访问控制只能是这两种：**public** 、**default** 。

    ```
    //public 访问呢权限的外部类，所有类都可以使用这个类
    public class OuterClass {
    
    }
    
    //default 权限的外部接口，所有类、接口均可以使用此接口
    interface OuterInterface{
        
    }
    ```

    类里面的成员的访问控制

    类里面的成员分为三类 ： **成员变量**、**成员方法**、**成员内部类（内部接口）**

    类里面的成员的访问控制可以是四种，也就是可以使用所有的访问控制权限

    ```
    public class OuterClass {
       
        public int aa; //可以被所有的类访问
        protected boolean bb; //可以被所有子类以及本包的类使用
        
        void cc() { //default 访问权限，能在本包范围内使用
            System.out.println("包访问权限");
        }
        
        //private权限的内部类，即这是私有的内部类，只能在本类使用
        private class InnerClass{
            
        }
    }
    ```

    **注意：**
    这里的类里面的成员 是指类的全局成员，并没有包括局部的成员（局部变量、局部内部类，没有局部内部接口）。或者说，局部成员是没有访问权限控制的，因为局部成员只在其所在的作用域内起作用，不可能被其他类访问到。

    ```
      public void count(){
        //局部成员变量
        public int amount;//编译无法通过，不能用public修饰
        int money;//编译通过
        //局部嵌套接口
        class customer{//编译通过
            
        }
    }
    ```

    上面的两种场景几乎可以适应所有的情况，但有一些情况比较特殊，还做了有些额外访问权限的要求

    抽象方法的访问权限

    普通方法是可以使用四种访问权限的，但抽象方法是有一个限制：不能用private 来修饰，也即抽象方法不能是私有的，否则，子类就无法继承实现抽象方法。

    接口成员的访问权限

    接口由于其的特殊性，所有成员的访问权限都规定得死死的，下面是接口成员的访问权限：

    - **变量：** public static final
    - **抽象方法：** public abstract
    - **静态方法：** public static，JDK1.8后才支持
    - **内部类、内部接口 ：** public static

    也因为所有的一切都默认强制规定好了，所以我们在用的时候，并不一定需要完整写出所有的修饰符，编译器会帮我们完成的，也就是，可以少写修饰符，但不能写错修饰符。

    ```
    public interface Interface_Test {
        
        public int aa = 6; //少写了  static final 
        int bb = 5; //
        
        //嵌套接口，可以不写public static
         interface cc{
            
        }
    }
    ```

    构造器的访问权限

    构造器的访问权限可以是以上四种权限中的任意一种：

    1、采用 private：一般是不允许直接构造这个类的对象，再结合工厂方法（static方法），实现单例模式。注意：所有子类都不能继承它。
    2、采用包访问控制：比较少用，这个类的对象只能在本包中使用，但是如果这个类有static 成员，那么这个类还是可以在外包使用；（也许可以用于该类的外包单例模式）。
    注意：外包的类不能继承这个类；
    3、采用 protected ：就是为了能让所有子类继承这个类，但是外包的非子类不能访问这个类；
    4、采用 public ：对于内外包的所有类都是可访问的；

    **注意：** 构造方法有点特殊，因为子类的构造器初始化时，都要调用父类的构造器，所以一旦父类构造器不能被访问，那么子类的构造器调用失败，意味子类继承父类失败！

  - 封装

    > 封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别

    这样做有什么好处？

    1. 只能通过规定的方法访问数据
    2. 隐藏类的实例细节，方便修改和实现。

    我们在开汽车的时候，只用去关注如何开车，我们并不在意车子是如何实现的，这就是封装。

    如何去实现类的封装呢？

    1. 修改属性的可见性，在属性的前面添加修饰符(private)

    2. 对每个值属性提供对外的公共方法访问，如创建 getter/setter（取值和赋值） 方法，用于对私有属性的访问

    3. 在 getter/setter 方法里加入属性的控制语句，例如我们可以加一个判断语句，对于非法输入给予否定。

       如果我们没有在属性前面添加任何修饰符，我们通过对象就可以直接对属性值进行修改，没有体现封装的特性。这在许多程序设计中都是不安全的，所以我们需要利用封装，来改进我们的代码。

       首先在类里要将属性前添加`private`修饰符。然后定义`getter`和`setter`方法。修改 People.java 和 NewObject.java 的内容如下。

       ```
       public class People {
       //属性（成员变量）有什么，前面添加了访问修饰符private
       //变成了私有属性，必须通过方法调用
           private double height;     //身高
       
       //属性已经封装好了，如果用户需要调用属性
       //必须用getter和setter方法进行调用
       //getter和setter方法需要程序员自己定义
           public double getHeight(){    
           //getter 方法命名是get关键字加属性名（属性名首字母大写）
           //getter 方法一般是为了得到属性值
               return height;
           }
       
       //同理设置我们的setter方法
       //setter 方法命名是set关键字加属性名（首字母大写）
       //setter 方法一般是给属性值赋值，所以有一个参数
           public void setHeight(double newHeight){
               height = newHeight;
           }
       }
       ```

       现在 main 函数里的对象，不能再直接调用属性了，只能通过`getter`和`setter`方法进行调用。

       ```
       public class NewObject {
       
           public static void main(String[] args) {
               People LiLei = new People();    //创建了一个People对象LiLei
       
               //利用setter方法为属性赋值
               LiLei.setHeight(170.0);
       
               //利用getter方法取属性值
               System.out.println("LiLei的身高是"+LiLei.getHeight());
               
           }
       }
       ```

  - this

    `this`关键字代表当前对象。使用`this.属性`操作当前对象的属性，`this.方法`调用当前对象的方法。

    用`private`修饰的属性，必须定义 getter 和 setter 方法才可以访问到(Eclipse IDEA 等 IDE 都有自动生成 getter 和 setter 方法的功能)。

    如下：

    ```
        public void setAge(int age) {
            this.age = age;
        }
        public int getAge() {
            return age;
        }
    ```

    创建好了 getter 和 setter 方法后，我们发现方法中参数名和属性名一样。

    当成员变量和局部变量之间发生冲突时，在属性名前面添加了`this`关键字。 此时就代表将一个参数的值赋给当前对象的属性。同理`this`关键字可以调用当前对象的方法，同学们自行验证一下吧。

  - spuer

    `super`关键字在子类内部使用，代表父类对象。

    1. 访问父类的属性 `super.属性名`
    2. 访问父类的方法 `super.bark()`
    3. 子类构造方法需要调用父类的构造方法时，在子类的构造方法体里**最前面**的位置：`super()`

  - 重载重写

    方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。方法重载一般用于创建一组任务相似但是参数不同的方法。

    ```
    public class Test {
        void f(int i) {
            System.out.println("i=" + i);
        }
    
        void f(float f) {
            System.out.println("f=" + f);
        }
    
        void f(String s) {
            System.out.println("s=" + s);
        }
    
        void f(String s1, String s2){
            System.out.println("s1+s2="+(s1+s2));
        }
    
        void f(String s, int i){
            System.out.println("s="+s+",i="+i);
        }
    
        public static void main(String[] args) {
            Test test = new Test();
            test.f(3456);
            test.f(34.56f);
            test.f("abc");
            test.f("abc","def");
            test.f("abc",3456);
        }
    }
    ```

    方法重载有以下几种规则：

    - 方法中的参数列表必须不同。比如：参数个数不同或者参数类型不同。
    - 重载的方法中允许抛出不同的异常
    - 可以有不同的返回值类型，但是参数列表必须不同
    - 可以有不同的访问修饰符

    方法重写

    子类可以继承父类的方法，但如果子类对父类的方法不满意，想在里面加入适合自己的一些操作时，就需要将方法进行重写。并且子类在调用方法中，优先调用子类的方法。

    比如 `Animal` 类中有`bark()`这个方法代表了动物叫，但是不同的动物有不同的叫法，比如狗是汪汪汪，猫是喵喵喵。

    当然在方法重写时要注意，重写的方法一定要与原父类的方法语法保持一致，比如返回值类型，参数类型及个数，和方法名都必须一致。

    例如：

    ```
    public class Animal {
        //类方法
        public void bark() {
            System.out.println("动物叫！");
        }
    }
    public class Dog extends Animal {
           //重写父类的bark方法
            public void bark() {
            System.out.println("汪！汪！汪！");
        }
    }
    ```

    写个测试类来看看输出结果：

    ```
    public class Test{
        public static void main(String args[]){
               Animal a = new Animal(); // Animal 对象
            Dog d = new Dog();   // Dog 对象
    
              Animal b = new Dog(); // Dog 对象,向上转型为Animal类型，具体会在后面的内容进行详解
    
              a.bark();// 执行 Animal 类的方法
             d.bark();//执行 Dog 类的方法
              b.bark();//执行 Dog 类的方法
           }
    }
    ```

  - 多态

    多态是指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。多态也称作动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。

    通俗地讲，只通过父类就能够引用不同的子类，这就是多态，我们只有在运行的时候才会知道引用变量所指向的具体实例对象。

    向上转型

    要理解多态必须要明白什么是"向上转型"，比如，一段代码如下，Dog 类是 Animal 类的子类：

    ```
    Animal a = new Animal();  //a是父类的引用指向的是本类的对象
    
    Animal b = new Dog(); //b是父类的引用指向的是子类的对象
    ```

    在这里，可以认为由于 Dog 继承于 Animal，所以 Dog 可以自动向上转型为 Animal，所以 b 是可以指向 Dog 实例对象的。

    > 注：不能使用一个子类的引用去指向父类的对象。

    如果定义了一个指向子类对象的父类引用类型，那么它除了能够引用父类中定义的所有属性和方法外，还可以使用子类强大的功能。但是对于只存在于子类的方法和属性就不能获取。

    新建一个`Test.java`，例如：

    ```
    class Animal {
        //父类方法
        public void bark() {
            System.out.println("动物叫！");
        }
    }
    
    class Dog extends Animal {
    
        //子类重写父类的bark方法
        public void bark() {
            System.out.println("汪、汪、汪！");
        }
        //子类自己的方法
        public void dogType() {
            System.out.println("这是什么品种的狗？");
        }
    }
    
    
    public class Test {
    
        public static void main(String[] args) {
            Animal a = new Animal();
            Animal b = new Dog();
            Dog d = new Dog(); 
    
            a.bark();
            b.bark();
            //b.dogType(); 
            //b.dogType()编译不通过
            d.bark();
            d.dogType();
        }
    
    }
    ```

    在这里，由于 b 是父类的引用，指向子类的对象，因此不能获取子类的方法（dogType()方法）,同时当调用 bark()方法时，由于子类重写了父类的 bark()方法,所以调用子类中的 bark()方法。

    ```
    因此，向上转型，在运行时，会遗忘子类对象中与父类对象中不同的方法，也会覆盖与父类中相同的方法——重写。（方法名，参数都相同）
    ```

    多态的实现条件

    Java 实现多态有三个必要条件：继承、重写和向上转型（即父类引用指向子类对象）。

    只有满足上述三个条件，才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。

    多态的实现方式

    Java 中多态的实现方式：继承父类进行方法重写，抽象类和抽象方法，接口实现。

  - 抽象类

    在定义类时，前面加上`abstract`关键字修饰的类叫抽象类。 抽象类中有抽象方法，这种方法是不完整的，仅有声明而没有方法体。抽象方法声明语法如下：

    ```
    abstract void f();  //f()方法时抽象方法
    ```

    那我们什么时候会用到抽象类呢？

    1. 在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。也就是说抽象类是约束子类必须要实现哪些方法，而并不关注方法如何去实现。
    2. 从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性。

    所以由上可知，抽象类是限制规定子类必须实现某些方法，但不关注实现细节。

    那抽象类如何用代码实现呢，它的规则如下：

    1. 用 abstract 修饰符定义抽象类
    2. 用 abstract 修饰符定义抽象方法，只用声明，不需要实现
    3. 包含抽象方法的类就是抽象类
    4. 抽象类中可以包含普通的方法，也可以没有抽象方法
    5. 抽象类的对象不能直接创建，通常是定义引用变量指向子类对象。

    example:

    1、目录下创建一个抽象类`TelePhone.java`。

    2、填写需要子类实现的抽象方法。

    ```
    //抽象方法
    public abstract class TelePhone {
        public abstract void call();  //抽象方法,打电话
        public abstract void message(); //抽象方法，发短信
    }
    ```

    3、构建子类，并实现抽象方法。新建一个`CellPhone.java`。

    ```
    public class CellPhone extends TelePhone {
    
        @Override
        public void call() {
            System.out.println("我可以打电话！");
        }
    
        @Override
        public void message() {
            System.out.println("我可以发短信！");
        }
    
        public static void main(String[] args) {
            CellPhone cp = new CellPhone();
            cp.call();
            cp.message();
        }
    
    }
    ```

  - 接口

    接口用于描述类所具有的功能，而不提供功能的实现，功能的实现需要写在实现接口的类中，并且该类必须实现接口中所有的未实现方法。

    接口的声明语法格式如下：

    ```
    修饰符 interface 接口名称 [extends 其他的接口名] {
            // 声明变量
            // 抽象方法
    }
    ```

    如声明一个 Animal 接口：

    ```
    // Animal.java
    interface Animal {
            //int x;
            //编译错误,x需要初始化，因为是 static final 类型
            int y = 5;
            public void eat();
            public void travel();
    }
    ```

    **注意点**：在`Java8`中

    - 接口不能用于实例化对象
    - 接口中方法只能是抽象方法、default 方法、静态方法
    - 接口成员是 static final 类型
    - 接口支持多继承

    在`Java9`中，接口可以拥有私有方法和私有静态方法，但是只能被该接口中的 default 方法和静态方法使用。

    多继承实现方式：

    ```
    修饰符 interface A extends 接口1，接口2{
    
    }
    
    修饰符 class A implements 接口1，接口2{
    
    } 
    ```

    实现上面的接口：

    ```
    // Cat.java
    public class Cat implements Animal{
    
         public void eat(){
             System.out.println("Cat eats");
         }
    
         public void travel(){
             System.out.println("Cat travels");
         }
         public static void main(String[] args) {
            Cat cat = new Cat();
            cat.eat();
            cat.travel();
        }
    }
    ```

  - 内部类

    将一个类的定义放在另一个类的定义内部，这就是内部类。而包含内部类的类被称为外部类。

    内部类的主要作用如下：

    1. 内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类
    2. 内部类的方法可以直接访问外部类的所有数据，包括私有的数据
    3. 内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便
    4. 内部类允许继承多个非接口类型（具体将在以后的内容进行讲解）

    > 注：内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。对于一个名为 outer 的外部类和其内部定义的名为 inner 的内部类。编译完成后出现 outer.class 和 outer$inner.class 两类。所以内部类的成员变量/方法名可以和外部类的相同。

    我们通过代码来详细学习一下内部类吧！

    成员内部类

    ```
    // People.java
    //外部类People
    public class People {
        private String name = "LiLei";         //外部类的私有属性
        //内部类Student
        public class Student {
            String ID = "20151234";               //内部类的成员属性
            //内部类的方法
            public void stuInfo(){
                System.out.println("访问外部类中的name：" + name);
                System.out.println("访问内部类中的ID：" + ID);
            }
        }
    
        //测试成员内部类
        public static void main(String[] args) {
            People a = new People();     //创建外部类对象，对象名为a
            Student b = a.new Student(); //使用外部类对象创建内部类对象，对象名为b
            // 或者为 People.Student b = a.new Student();
            b.stuInfo();   //调用内部对象的suInfo方法
        }
    }
    ```

    成员内部类的使用方法：

    1. Student 类相当于 People 类的一个成员变量，所以 Student 类可以使用任意访问修饰符
    2. Student 类在 People 类里，所以访问范围在类里的所有方法均可以访问 People 的属性（即内部类里可以直接访问外部类的方法和属性，反之不行）
    3. 定义成员内部类后，必须使用外部类对象来创建内部类对象，即 `内部类 对象名 = 外部类对象.new 内部类();`
    4. 如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this 关键字 如上述代码中：a.this

    > 注：成员内部类不能含有 static 的变量和方法，因为成员内部类需要先创建了外部类，才能创建它自己的。

    静态内部类

    静态内部类通常被称为嵌套类。

    ```
    // People.java
    //外部类People
    public class People {
        private String name = "LiLei";         //外部类的私有属性
    
    /*外部类的静态变量。
    Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。
    */
        static String ID = "510xxx199X0724XXXX"; 
    
        //静态内部类Student
        public static class Student {
            String ID = "20151234";               //内部类的成员属性
            //内部类的方法
            public void stuInfo(){
                System.out.println("访问外部类中的name：" + (new People().name));
                System.out.println("访问外部类中的ID：" + People.ID);
                System.out.println("访问内部类中的ID：" + ID);
            }
        }
    
        //测试成员内部类
        public static void main(String[] args) {
            Student b = new Student();   //直接创建内部类对象，对象名为b
            b.stuInfo();                 //调用内部对象的suInfo方法
        }
    }
    ```

    静态内部类是 static 修饰的内部类，这种内部类的特点是：

    1. 静态内部类不能直接访问外部类的非静态成员，但可以通过 `new 外部类().成员` 的方式访问
    2. 如果外部类的静态成员与内部类的成员名称相同，可通过`类名.静态成员`访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过`成员名`直接调用外部类的静态成员
    3. 创建静态内部类的对象时，不需要外部类的对象，可以直接创建 `内部类 对象名= new 内部类();`

    局部内部类

    局部内部类，是指内部类定义在方法和作用域内。

    例如：

    ```
    // People.java
    //外部类People
    public class People {    
        //定义在外部类中的方法内：
        public void peopleInfo() {
            final String sex = "man";  //外部类方法中的常量
            class Student {
                String ID = "20151234"; //内部类中的常量
                public void print() {
                    System.out.println("访问外部类的方法中的常量sex：" + sex);
                    System.out.println("访问内部类中的变量ID:" + ID);
                }
            }
            Student a = new Student();  //创建方法内部类的对象
            a.print();//调用内部类的方法
        }
        //定义在外部类中的作用域内
        public void peopleInfo2(boolean b) {
            if(b){
                final String sex = "man";  //外部类方法中的常量
                class Student {
                    String ID = "20151234"; //内部类中的常量
                    public void print() {
                        System.out.println("访问外部类的方法中的常量sex：" + sex);
                        System.out.println("访问内部类中的变量ID:" + ID);
                    }
                }
                Student a = new Student();  //创建方法内部类的对象
                a.print();//调用内部类的方法
            }
        }
        //测试方法内部类
        public static void main(String[] args) {
            People b = new People(); //创建外部类的对象
            System.out.println("定义在方法内：===========");
            b.peopleInfo();  //调用外部类的方法
            System.out.println("定义在作用域内：===========");
            b.peopleInfo2(true);
        }
    }
    ```

    

    局部内部类也像别的类一样进行编译，但只是作用域不同而已，只在该方法或条件的作用域内才能使用，退出这些作用域后无法引用的。

    匿名内部类

    匿名内部类，顾名思义，就是没有名字的内部类。正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写。但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口。

    例如：

    ```
    // Outer.java
    public class Outer { 
    
        public Inner getInner(final String name, String city) { 
            return new Inner() { 
                private String nameStr = name; 
                public String getName() { 
                    return nameStr; 
                } 
            };
        } 
    
        public static void main(String[] args) { 
            Outer outer = new Outer(); 
            Inner inner = outer.getInner("Inner", "NewYork"); 
            System.out.println(inner.getName()); 
        } 
    } 
    interface Inner { 
        String getName(); 
    }
    ```

    匿名内部类是`不能加访问修饰符`的。要注意的是，`new 匿名类，这个类是要先定义的`,如果不先定义，编译时会报错该类找不到。

    同时，在上面的例子中，当所在的方法的形参需要在内部类里面使用时，该形参必须为`final`。这里可以看到形参 name 已经定义为 final 了，而形参 city 没有被使用则不用定义为 final。

    然而，因为匿名内部类没名字，是用默认的构造函数的，无参数的，如果需要该类有带参数的构造函数，示例如下：

    ```
       public Inner getInner(final String name, String city) { 
            return new Inner(name, city) { 
                private String nameStr = name; 
    
                public String getName() { 
                    return nameStr; 
                } 
            }; 
        } 
    ```

    注意这里的形参 city，由于它没有被匿名内部类直接使用，而是被抽象类 Inner 的构造函数所使用，所以不必定义为 final。

  - java常用类

    java体统不少常用类，Arrays、StringBuilder、Calendar、String、Date、Math、Random、System、Scanner。java.util包。

    - String

      字符串，提供处理字符串的相关功能的处理，丰富的API。

    - Arrays

      Arrays 类包含用于操作数组的各种方法（例如排序和搜索）。还包含一个静态工厂，允许将数组转为 List。

      常用方法：

      | 方法                                     | 描述                             |
      | ---------------------------------------- | -------------------------------- |
      | `<T>` List`<T>` asList(T... a)           | 返回由指定数组构造的List         |
      | void sort(Object[] a)                    | 对数组进行排序                   |
      | void fill(Object[] a, Object val)        | 为数组的所有元素都赋上相同的值   |
      | boolean equals(Object[] a, Object[] a2)  | 检查两个数组是否相等             |
      | int binarySearch(Object[] a, Object key) | 对排序后的数组使用二分法查找数据 |

      > ```
      > public void ArrayTest(){
      >  int[] arr = new int[10];
      > 
      >  Arrays.fill(arr, 8);
      >  System.out.println(Arrays.toString(arr));
      >  Random random = new Random();
      >  for (int x: arr){
      >      x = random.nextInt(100);
      >  }
      >  System.out.println(Arrays.toString(arr));
      > 
      >  arr[5] = 50;
      >  Arrays.sort(arr);
      >  System.out.println(Arrays.toString(arr));
      >  System.out.println(Arrays.binarySearch(arr, 50));
      > 
      >  int[] arrNew = Arrays.copyOf(arr, arr.length);
      > 
      >  System.out.println(Arrays.equals(arr, arrNew));
      > 
      > }
      > ```

    - StringBuilder

      StringBuilder 类是可变的。它是 String 的对等类，它可以增加和编写字符的可变序列，并且能够将字符插入到字符串中间或附加到字符串末尾（当然是不用创建其他对象的）

      StringBuilder 的构造方法：

      | 构造方法                        | 说明                                                         |
      | ------------------------------- | ------------------------------------------------------------ |
      | StringBuilder()                 | 构造一个其中不带字符的 StringBuilder，其初始容量为 16 个字符 |
      | StringBuilder(CharSequence seq) | 构造一个 StringBuilder，它包含与指定的 CharSequence 相同的字符 |
      | StringBuilder(int capacity)     | 构造一个具有指定初始容量的 StringBuilder                     |
      | StringBuilder(String str)       | 并将其内容初始化为指定的字符串内容                           |

      StringBuilder 类的常用方法：

      | 方法                                    | 返回值        | 功能描述                                                     |
      | --------------------------------------- | ------------- | ------------------------------------------------------------ |
      | insert(int offsetm,Object obj)          | StringBuilder | 在 offsetm 的位置插入字符串 obj                              |
      | append(Object obj)                      | StringBuilder | 在字符串末尾追加字符串 obj                                   |
      | length()                                | int           | 确定 StringBuilder 对象的长度                                |
      | setCharAt(int index,char ch)            | void          | 使用 ch 指定的新值设置 index 指定的位置上的字符              |
      | toString()                              | String        | 转换为字符串形式                                             |
      | reverse()                               | StringBuilder | 反转字符串                                                   |
      | delete(int start, int end)              | StringBuilder | 删除调用对象中从 start 位置开始直到 end 指定的索引（end-1）位置的字符序列 |
      | replace(int start, int end, String str) | StringBuilder | 使用一组字符替换另一组字符。将用替换字符串从 start 指定的位置开始替换，直到 end 指定的位置结束 |

    - Calendar

      在早期的 JDK 版本中，Date 类附有两大功能： 　　

      1. 允许用年、月、日、时、分、秒来解释日期
      2. 允许对表示日期的字符串进行格式化和句法分析

      在 JDK1.1 中提供了类 Calendar 来完成第一种功能，类 DateFormat 来完成第二项功能。DateFormat 是 java.text 包中的一个类。与 Date 类有所不同的是，DateFormat 类可以接受用各种语言和不同习惯表示的日期字符串。

      但是 Calendar 类是一个抽象类，它完成 Date 类与普通日期表示法之间的转换，而我们更多的是使用 Calendar 类的子类 GregorianCalendar 类。它实现了世界上普遍使用的公历系统。当然我们也可以继承 Calendar 类，然后自己定义实现日历方法。

      先来看一看 GregorianCalendar 类的构造函数：

      | 构造方法                                        | 说明                                                         |
      | ----------------------------------------------- | ------------------------------------------------------------ |
      | GregorianCalendar()                             | 创建的对象中的相关值被设置成指定时区，缺省地点的当前时间，即程序运行时所处的时区、地点的当前时间 |
      | GregorianCalendar(TimeZone zone)                | 创建的对象中的相关值被设置成指定时区 zone，缺省地点的当前时间 |
      | GregorianCalendar(Locale aLocale)               | 创建的对象中的相关值被设置成缺省时区，指定地点 aLocale 的当前时间 |
      | GregorianCalendar(TimeZone zone,Locale aLocale) | year - 创建的对象中的相关值被设置成指定时区，指定地点的当前时间 |

      TimeZone 是 java.util 包中的一个类，其中封装了有关时区的信息。每一个时区对应一组 ID。类 TimeZone 提供了一些方法完成时区与对应 ID 两者之间的转换。

      > 太平洋时区id 为PST
      >
      > TimeZone   tz0 = TimeZone.getTimeZone("PST")
      >
      > 获得主机所处时区的对象
      >
      > TimeZone tz1 = TimeZone.getDefault()

      编程实例：

      > public void calendarTest(){
      >      System.out.println("显示完整日期");
      >
      > ```
      >  //日期格式
      >  DateFormat ftdate = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
      >  String str = ftdate.format(new Date());
      >  System.out.println(str);
      >  
      >  Calendar calendar = Calendar.getInstance();
      >  calendar.setTime(new Date());
      >  System.out.println("年：" + calendar.get(Calendar.YEAR));
      >  calendar.setTime(new Date());
      >  System.out.println((new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(calendar.getTime())));
      > ```
      >
      >  }

      其实 month 的含义与 Date 类相同，0 代表 1 月，11 代表 12 月。

      有的同学可能不明白最后一个的输出为什么有时是 0 ，有时是 1，在这里会涉及到 calendarNew 与 calendar 的创建时间点， calendarNew 经过增加和减少时间后恢复到原来的时间点，也就是最终比较的是谁先创建好，时间点靠后的大一些，而 calendarNew 创建的时间点只有可能是大于等于 calendar 的，需要根据实际的创建时间点进行比较。

    - Date

      Date 类表示日期和时间，里面封装了操作日期和时间的方法。Date 类经常用来获取系统当前时间。

      来看看类 Date 中定义的未过时的构造方法：

      | 构造方法        | 说明                                                         |
      | --------------- | ------------------------------------------------------------ |
      | Date()          | 构造一个 Date 对象并对其进行初始化以反映当前时间             |
      | Date(long date) | 构造一个 Date 对象，并根据相对于 GMT 1970 年 1 月 1 日 00:00:00 的毫秒数对其进行初始化 |

      Date 类的很多方法自 JDK 1.1 开始就已经过时了。

    - Math

      `Math` 类在 `java.lang` 包中，包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。

      常见方法：

      | 方法                    | 返回值                                         | 功能描述                                                     |
      | ----------------------- | ---------------------------------------------- | ------------------------------------------------------------ |
      | sin(double numvalue)    | double                                         | 计算角 numvalue 的正弦值                                     |
      | cos(double numvalue)    | double                                         | 计算角 numvalue 的余弦值                                     |
      | acos(double numvalue)   | double                                         | 计算 numvalue 的反余弦                                       |
      | asin(double numvalue)   | double                                         | 计算 numvalue 的反正弦                                       |
      | atan(double numvalue)   | double                                         | 计算 numvalue 的反正切                                       |
      | pow(double a, double b) | double                                         | 计算 a 的 b 次方                                             |
      | sqrt(double numvalue)   | double                                         | 计算给定值的正平方根                                         |
      | abs(int numvalue)       | int                                            | 计算 int 类型值 numvalue 的绝对值，也接收 long、float 和 double 类型的参数 |
      | ceil(double numvalue)   | double                                         | 返回大于等于 numvalue 的最小整数值                           |
      | floor(double numvalue)  | double                                         | 返回小于等于 numvalue 的最大整数值                           |
      | max(int a, int b)       | int                                            | 返回 int 型 a 和 b 中的较大值，也接收 long、float 和 double 类型的参数 |
      | min(int a, int b)       | int                                            | 返回 a 和 b 中的较小值，也可接受 long、float 和 double 类型的参数 |
      | rint(double numvalue)   | double                                         | 返回最接近 numvalue 的整数值                                 |
      | round(T arg)            | arg 为 double 时返回 long，为 float 时返回 int | 返回最接近arg的整数值                                        |
      | random()                | double                                         | 返回带正号的 double 值，该值大于等于 0.0 且小于 1.0          |

      上面都是一些常用的方法.

      > Math.abc(-127)
      >
      > Math.ceil(12.7)

    - System

      System 类提供了一下功能：

      - 标准输入，标准输出和错误输出流;
      - 访问外部定义的属性和环境变量;
      - 加载文件和库的方法;
      - 以及用于快速复制数组的实用方法。

      System 不可以被实例化，只可以使用其静态方法。

      ```
      //从指定的源数组中复制一个数组，从源数组指定的位置开始，到目标数组指定的位置
      public static void arraycopy(Object src,int srcPos, Object dest,int desPos,int length) 
      //返回以毫秒为单位的当前时间(从1970年到现在的毫秒数)
      public static long currentTimeMillis()  
      //终止当前正在运行的Java虚拟机，status为 0时退出
      public static void exit(int status)  
      //  运行垃圾收集器
      public static void gc() 
      // 取得当前系统的全部属性
      public static Properties getProperties()
      //获取指定键的系统属性
      public static String  getProperty(String key) 
      ```

  - 集合框架

    Java 使用集合来组织和管理对象。Collection、List、ArrayList、map、HashMap、Set、HashSet、算法、Queue。

  - 泛型

    泛型即参数化类型，也就是说数据类型变成了一个可变的参数，在不使用泛型的情况下，参数的数据类型都是写死了的，使用泛型之后，可以根据程序的需要进行改变。

    定义泛型的规则：

    - 只能是类类型，不能是简单数据类型
    - 泛型参数可以有多个
    - 可以用使用 extends 语句或者 super 语句 如`<T extends superClass>`表示类型的上界，T 只能是 superClass 或其子类， `<K super childClass>`表示类型的下界，K 只能是 childClass 或其父类。
    - 可以是通配符类型，比如常见的 Class<?>

  - 集合框架

    集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。任何集合框架都包含三大内容：对外的接口、接口的实现和对集合运算的算法。

    因为集合框架中的很多类功能是相似的，所以我们用接口来规范类。Collection 接口是 java 集合框架里的一个根接口。它也是 List、Set 和 Queue 接口的父接口。Collection 接口中定义了可用于操作 List、Set 和 Queue 的方法——增删改查。

    | 方法                             | 返回值      | 说明                                                         |
    | -------------------------------- | ----------- | ------------------------------------------------------------ |
    | add(E e)                         | boolean     | 向 collection 的尾部追加指定的元素（可选操作）               |
    | addAll(Collection<? extend E> c) | boolean     | 将指定 collection 中的所有元素都添加到此 collection 中（可选操作） |
    | clear()                          | void        | 移除此 collection 中的所有元素（可选操作）                   |
    | contains(Object o)               | boolean     | 如果此 collection 包含指定的元素，则返回 true                |
    | containsAll(Collection<?> c)     | boolean     | 如果此 collection 包含指定 collection 的所有元素，则返回 true |
    | equals(Object o)                 | boolean     | 比较此 collection 与指定对象是否相等                         |
    | hashCode()                       | int         | 返回此 collection 的哈希码值                                 |
    | isEmpty()                        | boolean     | 如果此 collection 不包含元素，则返回true                     |
    | iterator()                       | Iterator<E> | 返回在此 collection 的元素上进行迭代的迭代器                 |
    | remove(Object o)                 | boolean     | 移除此 collection 中出现的首个指定元素(可选操作)             |
    | removeAll(Collection<?> c)       | boolean     | 移除此 collection 中那些也包含在指定 collection 中的所有元素（可选操作） |
    | retainAll(Collection<?> c)       | boolean     | 仅保留此 collection 中那些也包含在指定 collection 的元素（可选操作） |
    | size()                           | int         | 返回此 collection 中的元素数                                 |
    | toArray()                        | Object[]    | 返回包含此 collection 中所有元素的数组                       |
    | toArray(T[] a)                   | <T> T[]     | 返回包含此 collection 中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同 |

    List

    `List` 是一个接口，`不能实例化`，需要一个具体类来实现实例化。List 集合中的对象按照一定的顺序排放，里面的内容可以重复。 `List` 接口实现的类有：`ArrayList`（实现动态数组），`Vector`（实现动态数组），`LinkedList`（实现链表），`Stack`（实现堆栈）。

    List 在 Collection 基础上增加的方法：

    | 方法                                         | 返回值          | 说明                                                         |
    | -------------------------------------------- | --------------- | ------------------------------------------------------------ |
    | add(int index, E element)                    | void            | 在列表的指定位置插入指定元素（可选操作）                     |
    | addAll(int index, Collection<? extends E> c) | boolean         | 将指定 collection 中的所有元素都插入到列表中的指定位置（可选操作） |
    | get(int index)                               | E               | 返回列表中指定位置的元素                                     |
    | indexOf(Object o)                            | int             | 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1 |
    | lastIndexOf(Object o)                        | int             | 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1 |
    | listIterator()                               | ListIterator<E> | 返回此列表元素的列表迭代器（按适当顺序）                     |
    | listIterator(int index)                      | ListIterator<E> | 返回此列表元素的列表迭代器（按适当顺序），从列表的指定位置开始 |
    | remove(int index)                            | E               | 移除列表中指定位置的元素（可选操作）                         |
    | set(int index, E element)                    | E               | 用指定元素替换列表中指定位置的元素（可选操作）               |
    | subList(int fromIndex, int toIndex)          | List<E>         | 返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的部分视图 |

    ArrayList

    ArrayList　类实现一个可增长的动态数组，位于 java.util.ArrayList<E>。实现了 List 接口，它可以存储不同类型的对象（包括 null 在内），而数组则只能存放特定数据类型的值。

    Map

    Map 接口也是一个非常重要的集合接口，用于存储键/值对。Map 中的元素都是成对出现的，键值对就像数组的索引与数组的内容的关系一样，将一个键映射到一个值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。我们可以通过键去找到相应的值。

    value 可以存储任意类型的对象，我们可以根据 key 键快速查找 value。Map 中的键/值对以 Entry 类型的对象实例形式存在。

    看一看 Map 中的方法吧

    | 方法                                    | 返回值              | 说明                                                         |
    | --------------------------------------- | ------------------- | ------------------------------------------------------------ |
    | clear()                                 | void                | 从此映射中移除所用映射关系（可选操作）                       |
    | containsKey(Object key)                 | boolean             | 如果此映射包含指定键的映射关系，则返回true                   |
    | containsValue(Object value)             | boolean             | 如果此映射将一个或多个键映射到指定值，则返回 true            |
    | entrySet()                              | Set<Map.Entry<K,V>> | 返回此映射中包含的映射关系的 Set 视图                        |
    | equals(Object o)                        | boolean             | 比较指定的对象与此映射是否相等                               |
    | get(Object key)                         | V                   | 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null |
    | hashCode()                              | int                 | 返回此映射的哈希码值                                         |
    | isEmpty()                               | boolean             | 如果此映射未包含键-值映射关系，则返回 true                   |
    | keySet()                                | Set<K>              | 返回此映射中包含的键的 Set 视图                              |
    | put(K key, V value)                     | V                   | 将指定的值与此映射中的指定键关联（可选操作）                 |
    | putAll(Map<? extends K, ? extends V> m) | void                | 从指定映射中将所有映射关系复制到此映射中（可选操作）         |
    | remove(Object key)                      | V                   | 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）   |
    | size                                    | int                 | 返回此映射中的键-值映射关系数                                |
    | values()                                | Collection<V>       | 返回此映射中包含的值的 Collection 视图                       |

    HashMap

    `HashMap` 是基于哈希表的 Map 接口的一个重要实现类。HashMap 中的 Entry 对象是`无序`排列的，Key 值和 value 值都可以为 null，但是一个 HashMap 只能有一个 key 值为 null 的映射（key 值不可重复）。

    Set 和 HashSet

    Set 接口也是 Collection 接口的子接口，它有一个很重要也是很常用的实现类——HashSet，Set 是元素无序并且不包含重复元素的 collection（List 可以重复），被称为集。

    HashSet 由哈希表（实际上是一个 HashMap 实例）支持。它不保证 set 的迭代顺序；特别是它不保证该顺序恒久不变。

    Collections

    `java.util.Collections` 是一个工具类，他包含了大量对集合进行操作的静态方法。

    常用方法

    | 方法名                                                      | 描述                                           |
    | ----------------------------------------------------------- | ---------------------------------------------- |
    | void sort(List list)                                        | 按自然升序排序                                 |
    | void sort(List list, Comparator c)                          | 自定义排序规则排序                             |
    | void shuffle(List list)                                     | 随机排序，用于打乱顺序                         |
    | void reverse(List list)                                     | 反转，将列表元素顺序反转                       |
    | void swap(List list, int i , int j)                         | 交换处于索引 i 和 j 位置的元素                 |
    | int binarySearch(List list, Object key)                     | 二分查找，列表必须有序，返回找到的元素索引位置 |
    | int max(Collection coll)                                    | 查找最大值                                     |
    | int min(Collection coll)                                    | 查找最小值                                     |
    | void fill(List list, Object obj)                            | 使用 obj 填充 list 所有元素                    |
    | boolean replaceAll(List list, Object oldVal, Object newVal) | 使用用 newVal 替换所有的 oldVal。              |
    | <K,V> Map<K,V> synchronizedMap(Map<K,V> m)                  | 将 m 包装为线程安全的 Map                      |
    | <T> List<T> synchronizedList(List<T> list)                  | 将 list 包装为线程安全的 List                  |

  - 算法

    算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量---维基百科。

  - 排序算法

    - 插入排序

      #### 插入排序

      > 有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法,插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为 O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。
      > 插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。

      排序过程如下：

      1. 从第一个元素开始，该元素可以认为已经被排序
      2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
      3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
      4. 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置
      5. 将新元素插入到该位置后
      6. 重复步骤 2~5

    - 冒泡

      > 冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。 它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从 A 到 Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素已经排序完成。 这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。

      冒泡排序的运行过程如下：

      - 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
      - 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
      - 针对所有的元素重复以上的步骤，除了最后一个。
      - 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较

    - 归并排序

      > 归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。

      排序过程：

      1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
      2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
      3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
      4. 重复步骤 3 直到某一指针到达序列尾
      5. 将另一序列剩下的所有元素直接复制到合并序列尾

    - 快速排序

      > 快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 n 个项目要 O(nlogn) 次比较。在最坏状况下则需要 O(n^2) 次比较，但这种状况并不常见。事实上，快速排序 O(nlogn)通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。

      快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。

      步骤为：

      1. 从数列中挑出一个元素，称为“基准”（pivot），
      2. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分割结束之后，该基准就处于数列的中间位置。这个称为**分割（partition）**操作。
      3. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。

      递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。

  - 搜索算法

    - 线性搜索

      线性搜索或顺序搜索是一种寻找某一特定值的搜索算法，指按一定的顺序检查数组中每一个元素，直到找到所要寻找的特定值为止。是最简单的一种搜索算法。

    - 二分查找

      分治思想

      在计算机科学中二分搜索（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语：logarithmic search），是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。

  - 异常处理

    认识异常、异常分类、声明和抛出、捕获异常、自定义异常、异常堆栈。

  - 认识异常

    异常指不期而至的各种状况，它在程序运行的过程中发生。作为开发者，我们都希望自己写的代码永远都不会出现bug，然而现实告诉我们并没有这样的情景。如果用户在程序的使用过程中因为一些原因造成他的数据丢失，这个用户就可能不会再使用该程序了。所以，对于程序的错误以及外部环境能够对用户造成的影响，我们应当及时报告并且以适当的方式来处理这个错误。

    之所以要处理异常，也是为了增强程序的[鲁棒性](http://baike.baidu.com/view/45520.htm)。

    异常都是从`Throwable`类派生出来的，而`Throwable`类是直接从`Object`类继承而来。你可以在 Java SE 官方 API 文档中获取更多关于它们的知识。

  - 异常分类

    异常通常有四类：

    - Error：系统内部错误，这类错误由系统进行处理，程序本身无需捕获处理
    - Exception：可以处理的异常
    - RuntimeException：可以捕获，也可以不捕获的异常
    - 继承 Exception 的其他类：必须捕获，通常在 API 文档中会说明这些方法抛出哪些异常

    平时主要关注的异常是 Exception 下的异常，而 Exception 异常下又主要分为两大类异常，一个是派生于 RuntimeExcption 的异常，一个是除了 RuntimeExcption 体系之外的其他异常。

    RuntimeExcption 异常(运行时异常)通常有以下几种：

    - 错误的类型转换
    - 数组访问越界
    - 访问 null 指针
    - 算术异常

    一般来说，RuntimeException 都是程序员的问题。

    非 RuntimeException（受查异常）一般有：

    - 打开一个不存在的文件
    - 没有找到具有指定名称的类
    - 操作文件异常

    受查异常是编译器要求必须处理的异常，必须使用 try catch 处理，或者向上抛出，给上层处理。

  - 异常声明和抛出

    throw 抛出异常

    当程序运行时数据出现错误或者我们不希望发生的情况出现的话，可以通过抛出异常来处理。

    异常抛出语法：

    ```
    throw new 异常名();
    throw new NullPointerException()
    ```

    throws 声明异常

    throws 用于声明异常，表示该方法可能会抛出的异常。如果声明的异常中包括 checked 异常（受查异常），那么调用者必须处理该异常或者使用 throws 继续向上抛出。throws 位于方法体前，多个异常使用`,`分割。

    > public static viod main(String[] args) throws FileNotFoundException{
    >
    > ​	//由方法的调用者捕获异常或者继续向上抛出
    >
    > }

  - 捕获异常

    通常抛出异常后，还需要将异常捕获。使用`try`和`catch`语句块来捕获异常，有时候还会用到`finally`。

    对于上述三个关键词所构成的语句块，`try`语句块是必不可少的，`catch`和`finally`语句块可以根据情况选择其一或者全选。你可以把可能发生错误或出现问题的语句放到`try`语句块中，将异常发生后要执行的语句放到`catch`语句块中，而`finally`语句块里面放置的语句，不管异常是否发生，它们都会被执行。

    你可能想说，那我把所有有关的代码都放到`try`语句块中不就妥当了吗？可是你需要知道，捕获异常对于系统而言，其开销非常大，所以应尽量减少该语句块中放置的语句。

    example：

    > package com.ws.ex;
    >
    > public class Main {
    >  public static void main(String[] args) {
    >      try {
    >          // 下面定义了一个try语句块
    >
    > ```
    >      System.out.println("I am try block.");
    >  
    >      Class<?> tempClass = Class.forName("");
    >      // 声明一个空的Class对象用于引发“类未发现异常”
    >      System.out.println("Bye! Try block.");
    >  
    >  } catch (ClassNotFoundException e) {
    >      // 下面定义了一个catch语句块
    >      System.out.println("I am catch block.");
    >  
    >      e.printStackTrace();
    >      //printStackTrace()的意义在于在命令行打印异常信息在程序中出错的位置及原因
    >  
    >      System.out.println("Goodbye! Catch block.");
    >  
    >  } finally {
    >      // 下面定义了一个finally语句块
    >      System.out.println("I am finally block.");
    >  }
    > ```
    >
    >  }
    > }

    - 捕获多个异常

      在一段代码中，可能会由于各种原因抛出多种不同的异常，而对于不同的异常，我们希望用不同的方式来处理它们，而不是笼统的使用同一个方式处理，在这种情况下，可以使用异常匹配，当匹配到对应的异常后，后面的异常将不再进行匹配。

      > 在处理异常时，并不要求抛出的异常同 catch 所声明的异常完全匹配，子类的对象也可以匹配父类的处理程序。比如异常 A 继承于异常 B，那么在处理多个异常时，一定要将异常 A 放在异常 B 之前捕获，如果将异常 B 放在异常 A 之前，那么将永远匹配到异常 B，异常 A 将永远不可能执行，并且编译器将会报错。
      >
      > public static void main(String[] args) {   
      >      try {  
      >          new FileInputStream("");  
      >      } catch (FileNotFoundException e) {  
      >          System.out.println("IO 异常");  
      >      } catch (Exception e) {  
      >          System.out.println("发生异常");  
      >      }  
      >  }    

      - 自定义异常

        尽管 Java SE 的 API 已经为我们提供了数十种异常类，然而在实际的开发过程中，仍然可能遇到未知的异常情况。此时，就需要对异常类进行自定义。

        自定义一个异常类非常简单，只需要让它继承 Exception 或其子类就行。在自定义异常类的时候，建议同时提供无参构造方法和带字符串参数的构造方法，后者可以在调试时提供更加详细的信息。

        > // MyAriException.java  
        > public class MyAriException extends ArithmeticException {  
        > //自定义异常类，该类继承自ArithmeticException  
        > public MyAriException() {  
        > }  
        > //实现默认的无参构造方法  
        > public MyAriException(String msg) {  
        > super(msg);  
        > }  
        > //实现可以自定义输出信息的构造方法，将待输出信息作为参数传入即可  
        > }   

        使用时throw new MyAriException("description")

  - 异常堆栈

    当异常抛出后，我们可以通过异常堆栈追踪程序的运行轨迹，以便我们更好的DEBUG。

    通过异常堆栈轨迹，在对比我们方法的调用过程，可以得出异常信息中首先打印的是距离抛出异常最近的语句，接着是调用该方法的方法，一直到最开始被调用的方法。从下往上看，就可以得出程序运行的轨迹。

  - Lambda

    lambda表达式、函数式接口、Stream流、flatMap。

  - 函数式编程

    函数式编程（英语：functional programming）或称函数程序设计，又称泛函编程，是一种编程典范，它将计算机运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。函数编程语言最重要的基础是λ演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。

  - lambda表达式

    一个 Lambda 表达式具有下面这样的语法特征。它由三个部分组成：第一部分为一个括号内用逗号分隔的参数列表，参数即函数式接口里面方法的参数；第二部分为一个箭头符号：`->`；第三部分为方法体，可以是表达式和代码块。语法如下：

    ```
    parameter -> expression body
    ```

    下面列举了 Lambda 表达式的几个最重要的特征：

    - 可选的类型声明：你不用去声明参数的类型。编译器可以从参数的值来推断它是什么类型。

    - 可选的参数周围的括号：你可以不用在括号内声明单个参数。但是对于很多参数的情况，括号是必需的。

    - 可选的大括号：如果表达式体里面只有一个语句，那么你不必用大括号括起来。

    - 可选的返回关键字：如果表达式体只有单个表达式用于值的返回，那么编译器会自动完成这一步。若要指示表达式来返回某个值，则需要使用大括号。

      > ```
      > package com.ws.ex;
      > 
      > public class LambdaTest {
      >  public static void main(String args[]){
      >      LambdaTest tester = new LambdaTest();
      > 
      >      // 带有类型声明的表达式
      >      MathOperation addition = (int a, int b) -> a + b;
      > 
      >      // 没有类型声明的表达式
      >      MathOperation subtraction = (a, b) -> a - b;
      > 
      >      // 带有大括号、带有返回语句的表达式
      >      MathOperation multiplication = (int a, int b) -> { return a * b; };
      > 
      >      // 没有大括号和return语句的表达式
      >      MathOperation division = (int a, int b) -> a / b;
      > 
      >      // 输出结果
      >      System.out.println("10 + 5 = " + tester.operate(10, 5, addition));
      >      System.out.println("10 - 5 = " + tester.operate(10, 5, subtraction));
      >      System.out.println("10 x 5 = " + tester.operate(10, 5, multiplication));
      >      System.out.println("10 / 5 = " + tester.operate(10, 5, division));
      > 
      >      // 没有括号的表达式
      >      GreetingService greetService1 = message ->
      >              System.out.println("Hello " + message);
      > 
      >      // 有括号的表达式
      >      GreetingService greetService2 = (message) ->
      >              System.out.println("Hello " + message);
      > 
      >      // 调用sayMessage方法输出结果
      >      greetService1.sayMessage("Shiyanlou");
      >      greetService2.sayMessage("Classmate");
      >  }
      > 
      >  // 下面是定义的一些接口和方法
      > 
      >  interface MathOperation {
      >      int operation(int a, int b);
      >  }
      > 
      >  interface GreetingService {
      >      void sayMessage(String message);
      >  }
      > 
      >  private int operate(int a, int b, MathOperation mathOperation){
      >      return mathOperation.operation(a, b);
      >  }
      > }
      > ```

      - Lambda 表达式优先用于定义功能接口在行内的实现，即单个方法只有一个接口。在上面的例子中，我们用了多个类型的 Lambda 表达式来定义 MathOperation 接口的操作方法。然后我们定义了 GreetingService 的 sayMessage 的实现。
      - Lambda 表达式让匿名类不再需要，这为 Java 增添了简洁但实用的函数式编程能力。

    - 作用域

      我们可以通过下面这段代码来学习 Lambda 的作用域。请将代码修改至如下这些：

      ```
      public class LamdbaTest {
              final static String salutation = "Hello "; //正确，不可再次赋值
              //static String salutation = "Hello "; //正确，可再次赋值
              //String salutation = "Hello "; //报错
              //final String salutation = "Hello "; //报错
      
          public static void main(String args[]){
              //final String salutation = "Hello "; //正确，不可再次赋值
              //String salutation = "Hello "; //正确，隐性为 final , 不可再次赋值
      
              // salution = "welcome to "  
              GreetingService greetService1 = message -> 
              System.out.println(salutation + message);
              greetService1.sayMessage("Shiyanlou");
          }
      
          interface GreetingService {
             void sayMessage(String message); 
          }
      }
      ```

      可以得到以下结论：

      - 可访问 static 修饰的成员变量，如果是 final static 修饰，不可再次赋值，只有 static 修饰可再次赋值；
      - 可访问表达式外层的 final 局部变量（不用声明为 final，隐性具有 final 语义），不可再次赋值。

    - 方法引用

      方法引用提供了一个很有用的语义来直接访问类或者实例的已经存在的方法或者构造方法。

      方法引用可以通过方法的名字来引用其本身。方法引用是通过`::`符号（双冒号）来描述的。

      它可以用来引用下列类型的方法：

      - 构造器引用。语法是 Class::new，或者更一般的 Class< T >::new，要求构造器方法是没有参数；
      - 静态方法引用。语法是 Class::static_method。
      - 特定类的任意对象方法引用。它的语法是 Class::method。
      - 特定对象的方法引用，它的语法是 instance::method。

      下面是一个简单的方法引用的例子。

      ```
      // LamdbaTest.java
      import java.util.List;
      import java.util.ArrayList;
      
      public class LamdbaTest {
      
          public static void main(String args[]){
              List<String> names = new ArrayList<>();
      
              names.add("Peter");
              names.add("Linda");
              names.add("Smith");
              names.add("Zack");
              names.add("Bob");
      
              //     通过System.out::println引用了输出的方法
              names.forEach(System.out::println);
          }
      }
      ```

    - 函数式接口

      函数式接口是只包含一个方法的接口。例如，带有单个`compareTo`方法的比较接口，被用于比较的场合。Java 8 开始定义了大量的函数式接口来广泛地用于 lambda 表达式。

      java.util.function 包中包含了大量的函数式接口，基本可以满足我们的日常开发需求。

      下面是部分函数式接口的列表。

      | 接口                 | 描述                                                         |
      | -------------------- | ------------------------------------------------------------ |
      | BitConsumer<T,U>     | 该接口代表了接收两个输入参数 T、U，并且没有返回的操作        |
      | BiFunction<T,U,R>    | 该接口代表提供接收两个参数 T、U，并且产生一个结果 R 的方法   |
      | BinaryOperator<T>    | 代表了基于两个相同类型的操作数，产生仍然是相同类型结果的操作 |
      | BiPredicate<T,U>     | 代表了对两个参数的断言操作（基于 Boolean 值的方法）          |
      | BooleanSupplier      | 代表了一个给出 Boolean 值结果的方法                          |
      | Consumer<T>          | 代表了接受单一输入参数并且没有返回值的操作                   |
      | DoubleBinaryOperator | 代表了基于两个 Double 类型操作数的操作，并且返回一个 Double 类型的返回值 |
      | DoubleConsumer       | 代表了一个接受单个 Double 类型的参数并且没有返回的操作       |
      | DoubleFunction<R>    | 代表了一个接受 Double 类型参数并且返回结果的方法             |
      | DoublePredicate      | 代表了对一个 Double 类型的参数的断言操作                     |
      | DoubleSupplier       | 代表了一个给出 Double 类型值的方法                           |
      | DoubleToIntFunction  | 代表了接受单个 Double 类型参数但返回 Int 类型结果的方法      |
      | DoubleToLongFunction | 代表了接受单个 Double 类型参数但返回 Long 类型结果的方法     |
      | DoubleUnaryOperator  | 代表了基于单个 Double 类型操作数且产生 Double 类型结果的操作 |
      | Function<T,R>        | 代表了接受一个参数并且产生一个结果的方法                     |
      | IntBinaryOperator    | 代表了对两个 Int 类型操作数的操作，并且产生一个 Int 类型的结果 |
      | IntConsumer          | 代表了接受单个 Int 类型参数的操作，没有返回结果              |
      | IntFunction<R>       | 代表了接受 Int 类型参数并且给出返回值的方法                  |
      | IntPredicate         | 代表了对单个 Int 类型参数的断言操作                          |

      更多的接口可以参考 Java 官方 API 手册：[java.lang.Annotation Type FunctionalInterface](https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html)。在实际使用过程中，加有`@FunctionalInterface`注解的方法均是此类接口，位于[`java.util.Funtion`包中](http://docs.oracle.com/javase/8/docs/api/java/util/function/package-frame.html)。

      > ```
      > import java.util.Arrays;
      > import java.util.List;
      > import java.util.function.Predicate;
      > 
      > public class FunctionTest {
      > public static void main(String args[]){
      >    List<Integer> list = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
      > 
      >    System.out.println("All of the numbers:");
      > 
      >    eval(list, n->true);
      > 
      >    System.out.println("Even numbers:");
      >    eval(list, n-> n%2 == 0 );
      > 
      >    System.out.println("Numbers that greater than  5:");
      >    eval(list, n -> n > 5 );
      > }
      > 
      > public static void eval(List<Integer> list, Predicate<Integer> predicate) {
      >    for(Integer n: list) {
      > 
      >       if(predicate.test(n)) {
      >          System.out.println(n);
      >       }
      >    }
      > }
      > }
      > ```

  - stream 流

    Stream 是 Java 8 开始的一个新的抽象层。通过使用 Stream，你能以类似于 SQL 语句的声明式方式处理数据。

    例如一个典型的 SQL 语句能够自动地返回某些信息，而不用在开发者这一端做任何的计算工作。同样，通过使用 Java 的集合框架，开发者能够利用循环做重复的检查。另外一个关注点是效率，就像多核处理器能够提升效率一样，开发者也可以通过并行化编程来改进工作流程，但是这样很容易出错。

    因此，Stream 的引入是为了解决上述痛点。开发者可以通行声明式数据处理，以及简单地利用多核处理体系而不用写特定的代码。

    说了这么久，Stream 究竟是什么呢？Stream 代表了来自某个源的对象的序列，这些序列支持聚集操作。下面是 Stream 的一些特性：

    - 元素序列：Stream 以序列的形式提供了特定类型的元素的集合。根据需求，它可以获得和计算元素，但不会储存任何元素。
    - 源：Stream 可以将集合、数组和 I/O 资源作为输入源。
    - 聚集操作：Stream 支持诸如`filter`、`map`、`limit`、`reduce`等的聚集操作。
    - 流水技术：许多 Stream 操作返回了流本身，故它们的返回值可以以流水的行式存在。这些操作称之为中间操作，并且它们的功能就是负责输入、处理和向目标输出。`collect()`方法是一个终结操作，通常存在于流水线操作的末端，来标记流的结束。
    - 自动迭代：Stream 的操作可以基于已提供的源元素进行内部的迭代，而集合则需要显式的迭代。

    集合的接口有两个方法来产生流：

    - `stream()`：该方法返回一个将集合视为源的连续流。
    - `parallelStream()`：该方法返回一个将集合视为源的并行流。

    其他相关方法：

    - `forEach`：该方法用于对 Stream 中的每个元素进行迭代操作。下面的代码段演示了如何使用 forEach 方法输出 10 个随机数。

    ```
    Random random = new Random();
    random.ints().limit(10).forEach(System.out::println);
    ```

    - `map`：该方法用于将每个元素映射到对应的结果上。下面的代码段演示了怎样用 map 方法输出唯一的某个数的平方。

    ```
    List<Integer> numbers = Arrays.asList(2, 3, 3, 2, 5, 2, 7);
    //get list of unique squares
    List<Integer> squaresList = numbers.stream().map( i -> i*i).distinct().collect(Collectors.toList());
    ```

    - `filter`：该方法用于过滤满足条件的元素。下面的代码段演示了怎样输出使用了过滤方法的空字符串数量。

    ```
    List<String>strings = Arrays.asList("efg", "", "abc", "bc", "ghij","", "lmn");
    //get count of empty string
    long count = strings.stream().filter(string -> string.isEmpty()).count();
    ```

    - `limit`：该方法用于减少 Stream 的大小。下面的代码段演示了怎样有限制地输出 10 个随机数。

    ```
    Random random = new Random();
    random.ints().limit(10).forEach(System.out::println);
    ```

    - `sorted`：该方法用于对 Stream 排序。下面的代码段演示了怎样以有序的形式输出 10 个随机数。

    ```
    Random random = new Random();
    random.ints().limit(10).sorted().forEach(System.out::println);
    ```

    并行处理

    ParallelStream 是 Stream 用于并行处理的一种替代方案。下面的代码段演示了如何使用它来输出空字符串的数量。

    ```
    List<String> strings = Arrays.asList("efg", "", "abc", "bc", "ghij","", "lmn");
    
    // 获得空字符串的计数
    long count = strings.parallelStream().filter(String::isEmpty).count();
    ```

    当然，在连续的 Stream 与并行的 Stream 之间切换是很容易的。

    Collector

    Collector 用于合并 Stream 的元素处理结果。它可以用于返回一个字符串列表。

    下面的代码段演示了如何使用它。

    ```
    List<String>strings = Arrays.asList("efg", "", "abc", "bc", "ghij","", "lmn");
    List<String> filtered = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.toList());
    
    System.out.println("Filtered List: " + filtered);
    String mergedString = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.joining(", "));
    System.out.println("Merged String: " + mergedString);
    
    统计工具
    ```

    Stream 处理完成后使用 Collector 来统计数据。

    下面的代码段演示了如何使用它。

    ```
    List<Integer> numbers = Arrays.asList(2, 3, 3, 2, 5, 2, 7);
    
    IntSummaryStatistics stats = numbers.stream().mapToInt((x) -> x).summaryStatistics();
    
    System.out.println("Highest number in List : " + stats.getMax());
    System.out.println("Lowest number in List : " + stats.getMin());
    System.out.println("Sum of all numbers : " + stats.getSum());
    System.out.println("Average of all numbers : " + stats.getAverage());
    ```

  - FlatMap

    FlatMap 用于将多个流合并为一个流，使用 FlatMap 时，表达式的返回值必须是 Stream 类型。而 Map 用于将一种流转化为另外一个流。

    考虑以下场景，有三个字符串("shi yan", "shi yan lou","lou yan shi")，我们希望将字符串使用空格分割，提取出单个单词。

    ```
    import java.util.Arrays;
    import java.util.stream.Stream;
    
    public class FlatMapTest {
        public static void main(String[] args) {
            Stream<String> stringStream1 = Stream.of("shi yan", "shi yan lou","lou yan shi");
            Stream<String> stringStream2 = Stream.of("shi yan", "shi yan lou","lou yan shi");
            Stream<String[]> mapStream = stringStream1
                    //map将一种类型的流 转换为另外一个类型的流  这里转换成了String[]流 
                    //这并不是我们想要的，我们想要的是Stream<String>,而不是Stream<String[]>
                    .map(v -> v.split(" "));
            Stream<String> flatMapStream = stringStream2
                    //Arrays.stream将数组转换成了流 这里将分割后的String[]，转换成了Stream<String>，但是我们前面定义了三个字符串
                    //所以这里将产生三个Stream<String>，flatMap用于将三个流合并成一个流
                    .flatMap(v -> Arrays.stream(v.split(" ")));
            System.out.println("mapStream打印：");
            mapStream.peek(System.out::println).count();
            System.out.println("flatMapStream打印：");
            flatMapStream.peek(System.out::println).count();
    
        }
    }
    ```

  - io

    java.io 包里面最重要的5个类：File、OutputStream、InputStream、Write、Reader。

    主要研究的内容：

    文件、读写、文件操作、copy、文件属性、目录读取、IO流、字节流、字符流。

    > #### 构造方法
    >
    > File 类提供了以下构造方法：
    >
    > ```
    > //根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。 
    > File(File parent, String child) 
    > 
    > //通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例       
    > File(String pathname) 
    > 
    > // 根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例
    > File(String parent, String child) 
    > 
    > //通过将给定的 file: URI 转换为一个抽象路径名来创建一个新的 File 实例
    > File(URI uri) 
    > ```
    >
    > #### 使用示例
    >
    > ```
    > //一个目录路径参数
    > File f1 = new File("/home/project/");
    > 
    > //对象有两个参数——路径和文件名
    > File f2 = new File("/home/project/","a.bat");
    > 
    > //指向f1文件的路径及文件名
    > File f3 = new File(f1,"a.bat");
    > ```
    >
    > #### 常用方法
    >
    > 来看看 File 的一些常用方法
    >
    > | 方法                                                         | 说明                                                         |
    > | ------------------------------------------------------------ | ------------------------------------------------------------ |
    > | boolean canExecute()                                         | 测试应用程序是否可以执行此抽象路径名表示的文件               |
    > | boolean canRead()                                            | 测试应用程序是否可以读取此抽象路径名表示的文件               |
    > | boolean canWrite()                                           | 测试应用程序是否可以修改此抽象路径名表示的文件               |
    > | int compareTo(File pathname)                                 | 按字母顺序比较两个抽象路径名                                 |
    > | boolean createNewFile()                                      | 当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件 |
    > | static File createTempFile(String prefix, String suffix)     | 在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称 |
    > | static File createTempFile(String prefix, String suffix, File directory) | 在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称 |
    > | boolean delete()                                             | 删除此抽象路径名表示的文件或目录                             |
    > | void deleteOnExit()                                          | 在虚拟机终止时，请求删除此抽象路径名表示的文件或目录         |
    > | boolean equals(Object obj)                                   | 测试此抽象路径名与给定对象是否相等                           |
    > | boolean exists()                                             | 测试此抽象路径名表示的文件或目录是否存在                     |
    > | File getAbsoluteFile()                                       | 返回此抽象路径名的绝对路径名形式                             |
    > | String getAbsolutePath()                                     | 返回此抽象路径名的绝对路径名字符串                           |
    > | File getCanonicalFile()                                      | 返回此抽象路径名的规范形式                                   |
    > | String getCanonicalPath()                                    | 返回此抽象路径名的规范路径名字符串                           |
    > | long getFreeSpace()                                          | 返回此抽象路径名指定的分区中未分配的字节数                   |
    > | String getName()                                             | 返回由此抽象路径名表示的文件或目录的名称                     |
    > | String getParent()                                           | 返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 null |
    > | File getParentFile()                                         | 返回此抽象路径名父目录的抽象路径名；如果此路径名没有指定父目录，则返回 null |
    > | String getPath()                                             | 将此抽象路径名转换为一个路径名字符串                         |
    > | long getTotalSpace()                                         | 返回此抽象路径名指定的分区大小                               |
    > | long getUsableSpace()                                        | 返回此抽象路径名指定的分区上可用于此虚拟机的字节数           |
    > | int hashCode()                                               | 计算此抽象路径名的哈希码                                     |
    > | boolean isAbsolute()                                         | 测试此抽象路径名是否为绝对路径名                             |
    > | boolean isDirectory()                                        | 测试此抽象路径名表示的文件是否是一个目录                     |
    > | boolean isFile()                                             | 测试此抽象路径名表示的文件是否是一个标准文件                 |
    > | boolean isHidden()                                           | 测试此抽象路径名指定的文件是否是一个隐藏文件                 |
    > | long lastModified()                                          | 返回此抽象路径名表示的文件最后一次被修改的时间               |
    > | long length()                                                | 返回由此抽象路径名表示的文件的长度                           |
    > | String[] list()                                              | 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录 |
    > | String[] list(FilenameFilter filter)                         | 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录 |
    > | File[] listFiles()                                           | 返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件 |
    > | File[] listFiles(FileFilter filter)                          | 返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录 |
    > | File[] listFiles(FilenameFilter filter)                      | 返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录 |
    > | static File[] listRoots()                                    | 列出可用的文件系统根                                         |
    > | boolean mkdir()                                              | 创建此抽象路径名指定的目录                                   |
    > | boolean mkdirs()                                             | 创建此抽象路径名指定的目录，包括所有必需但不存在的父目录     |
    > | boolean renameTo(File dest)                                  | 重新命名此抽象路径名表示的文件                               |
    > | boolean setExecutable(boolean executable)                    | 设置此抽象路径名所有者执行权限的一个便捷方法                 |
    > | boolean setExecutable(boolean executable, boolean ownerOnly) | 设置此抽象路径名的所有者或所有用户的执行权限                 |
    > | boolean setLastModified(long time)                           | 设置此抽象路径名指定的文件或目录的最后一次修改时间           |
    > | boolean setReadable(boolean readable)                        | 设置此抽象路径名所有者读权限的一个便捷方法                   |
    > | boolean setReadable(boolean readable, boolean ownerOnly)     | 设置此抽象路径名的所有者或所有用户的读权限                   |
    > | boolean setReadOnly()                                        | 标记此抽象路径名指定的文件或目录，从而只能对其进行读操作     |
    > | boolean setWritable(boolean writable)                        | 设置此抽象路径名所有者写权限的一个便捷方法                   |
    > | boolean setWritable(boolean writable, boolean ownerOnly)     | 设置此抽象路径名的所有者或所有用户的写权限                   |
    > | String toString()                                            | 返回此抽象路径名的路径名字符串                               |
    > | URI toURI()                                                  | 构造一个表示此抽象路径名的 file: URI                         |
    >
    > #### 编程实例
    >
    > ```
    > import java.io.File;
    > import java.io.IOException;
    > 
    > public class  FileDemo {
    >  public static void main(String[] args){
    >      //同学们可以根据自己的路径进行更改
    >      File f1 =new
    >      File("/home/project/1.txt");
    >      //File(String parent,String child)
    >      File f2 =new File("/home/project","2.txt");
    >      //separator 跨平台分隔符
    >      File f3 =new File("/home"+File.separator+"project");
    >      File f4 =new File(f3,"3.txt");
    > 
    >      try {
    >           System.out.println(f1);
    >              //当文件存在时返回 false；不存在时返回 true
    >              System.out.println(f2.createNewFile());
    >              //当文件不存在时返回 false
    >              System.out.println(f3.delete());
    >      }catch(IOException e) {
    >              e.printStackTrace();
    >      }
    > 
    >      //列出磁盘下的文件和文件夹
    >      File[] files =File.listRoots();
    >      for(File file:files){
    >          System.out.println(file);
    >          if(file.length()>0){
    >              String[] filenames =file.list();
    >              for(String filename:filenames){
    >                  System.out.println(filename);
    >              }
    >          }
    >      }
    >  }
    > 
    > }
    > ```

  - 文件流

    > java.io 包中提供了文件操作类：
    >
    > 1. 用于读写本地文件系统中的文件：FileInputStream 和 FileOutputStream
    > 2. 描述本地文件系统中的文件或目录：File、FileDescriptor 和 FilenameFilter
    > 3. 提供对本地文件系统中文件的随机访问支持：RandomAccessFile
    >
    > 接下来将学习文件流的 FileInputStream 和 FileOutputStream 。
    >
    > FileInputStream 类用于打开一个输入文件，若要打开的文件不存在，则会产生异常 FileNotFoundException，这是一个非运行时异常，必须捕获或声明抛弃；
    >
    > FileOutputStream 类用来打开一个输出文件，若要打开的文件不存在，则会创建一个新的文件，否则原文件的内容会被新写入的内容所覆盖；
    >
    > 在进行文件的读/写操作时，会产生非运行时异常 IOException，必须捕获或声明抛弃（其他的输入/输出流处理时也同样需要进行输入/输出异常处理）。
    >
    > #### 文件流的构造方法
    >
    > ```
    > //打开一个以 f 描述的文件作为输入
    > FileInputStream(File f)
    > 
    > //打开一个文件路径名为 name 的文件作为输入
    > FileInputStream(String name)
    > 
    > //创建一个以 f 描述的文件作为输出
    > //如果文件存在，则其内容被清空
    > FileOutputStream(File f)
    > 
    > //创建一个文件路径名为 name 的文件作为输出
    > //文件如果已经存在，则其内容被清空
    > FileOutputStream(String name)
    > 
    > //创建一个文件路径名为 name 的文件作为输出
    > //文件如果已经存在，则在该输出上输出的内容被接到原有内容之后
    > FileOutputStream(String name, boolean append)
    > ```
    >
    > #### 代码示例
    >
    > ```
    > File f1 = new File("file1.txt");
    > File f2 = new File("file2.txt");
    > FileInputStream in = new FileInputStream(f1);
    > FileOutputStream out = new FileOutputStream(f2);
    > ```
    >
    > 输入流的参数是用于指定输入的文件名，输出流的参数则是用于指定输出的文件名。
    >
    > #### 编程实战
    >
    > ```
    > import java.io.File;
    > import java.io.FileInputStream;
    > import java.io.FileNotFoundException;
    > import java.io.FileOutputStream;
    > import java.io.IOException;
    > 
    > public class Test {
    > 
    >  public static void main(String[] args) {
    >      try {
    >          //inFile 作为输入流的数据文件必须存在，否则抛出异常
    >          File inFile = new File("/home/project/file1.txt");
    > 
    >          //file2.txt没有，系统可以创建
    >          File outFile = new File("file2.txt");
    >          FileInputStream fis = new FileInputStream(inFile);
    >          FileOutputStream fos = new FileOutputStream(outFile);
    >          int c;
    >          while((c = fis.read()) != -1){
    >              fos.write(c);
    >          }
    >          //打开了文件一定要记着关，释放系统资源
    >          fis.close();
    >          fos.close();
    >      }catch(FileNotFoundException e) {
    >          System.out.println("FileStreamsTest:" + e);
    >      }catch(IOException e){
    >          System.err.println("FileStreamTest:" + e);
    >      }
    >  }
    > }
    > ```

  - IO流

    > 在大多数程序中，都需要对输入输出进行处理。例如我们中需要获取用户从键盘上的输入，需要在控制台输出结果等等。除此之外还有从文件中读取数据，向文件中写入数据等等。在 Java 中，我们把这些不同类型的输入输出源抽象地称为`流`，也就是`Stream`；在里面输入输出的数据则称为`数据流`（`Data Stream`），它们通常具有统一的接口。
    >
    > 于是我们得到了数据流的定义：
    >
    > > 一个 Java I/O 对象叫做数据流。读取数据到内存的对象叫做输入流，内存写出数据的对象叫做输出流。
    >
    > 针对其面向的不同角度，我们大致可以将流分为下面几种类型：
    >
    > - 按照数据流的方向不同分为`输入流`和`输出流`。这种分类不是绝对的，例如在向一个文件写入数据时，它就是输出流；而在读取数据时，它就是输入流。
    > - 按照处理数据的单位不同分为`字节流`和`字符流`。
    > - 按照功能的不同分为`节点流`和`处理流`。
    >
    > 需要特别说明，节点流是从特定的数据节点（文件、数据库、内存等）读写数据；处理流是连接在已有的流上，通过对数据的处理为程序提供更多功能。
    >
    > 在 Java 环境中，`java.io`包提供了大多数的类和接口来实现输入输出管理。一些标准的输入输出则来自`java.lang`包中的类，但它们都是继承自`java.io`中的类。我们可以将输入流理解为数据的提供者，而把输出流理解为数据的接收者。在最初的时候，这些派生自抽象类`InputStream`和`OutputStream`的输入输出类是面向 8 位的字节流的。但为了支持国际化，又引入了派生自抽象类`Reader`和`Writer`的类层次，用于读写一些双字节的`Unicode`字符。
    >
    > **因此，在学习 java 的输入输出上，我们希望你以字节流和字符流作为区分来学习。**
    >
    > 如果需要概括一下，则可以得到下面的定义：
    >
    > > - 字节流：表示以字节为单位从 stream 中读取或往 stream 中写入信息。通常用来读取二进制数据。
    >
    > > - 字符流：以 Unicode 字符为单位从 stream 中读取或往stream 中写入信息。
    >
    > 按照这样的定义，Java 中流的层级结构可以通过图来表示：
    >
    > java14 15
    >
    > 为了能够永久地保存对象的状态，`java.io`包还以字节流为基础，通过实现`ObjectInput`和`ObjectOutput`接口提供了`对象流`。在此仅作引入，你可以通过查阅 API 手册来详细了解它们。

  - 字节流

    > 字节流主要操作 byte 类型数据，以 byte 数组为准，java 中每一种字节流的基本功能依赖于基本类 InputStream 和 Outputstream，他们是抽象类，不能直接使用。`字节流能处理所有类型的数据（如图片、avi等）`。
    >
    > #### InputStream
    >
    > InputStream 是所有表示字节输入流的父类，继承它的子类要重新定义其中所定义的抽象方法。InputStream 是从装置来源地读取数据的抽象表示，例如 System 中的标准输入流 in 对象就是一个 InputStream 类型的实例。
    >
    > **InputStream 类方法：**
    >
    > | 方法                                  | 说明                                                     |
    > | ------------------------------------- | -------------------------------------------------------- |
    > | read()throws IOException              | 从输入流中读取数据的下一个字节（抽象方法）               |
    > | skip(long n) throws IOException       | 跳过和丢弃此输入流中数据的 n 个字节                      |
    > | available()throws IOException         | 返回流中可用字节数                                       |
    > | mark(int readlimit)throws IOException | 在此输入流中标记当前的位置                               |
    > | reset()throws IOException             | 将此流重新定位到最后一次对此输入流调用 mark 方法时的位置 |
    > | markSupport()throws IOException       | 测试此输入流是否支持 mark 和 reset 方法                  |
    > | close()throws IOException             | 关闭流                                                   |
    >
    > 在 InputStream 类中，方法 read() 提供了三种从流中读数据的方法：
    >
    > 1. int read()：从输入流中读一个字节，形成一个 0~255 之间的整数返回（是一个抽象方法）
    > 2. int read(byte b[])：从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。
    > 3. int read(byte b[],int off,int len)：从输入流中读取长度为 len 的数据，写入数组 b 中从索引 off 开始的位置，并返回读取得字节数。
    >
    > 对于这三个方法，若返回-1，表明流结束，否则，返回实际读取的字符数。
    >
    > #### OutputStream
    >
    > OutputStream 是所有表示位输出流的类之父类。子类要重新定义其中所定义的抽象方法，OutputStream 是用于将数据写入目的地的抽象表示。例如 System 中的标准输出流对象 out 其类型是java.io.PrintStream，这个类是 OutputStream 的子类。
    >
    > **OutputStream 类方法：**
    >
    > | 方法                                                | 说明                                                         |
    > | --------------------------------------------------- | ------------------------------------------------------------ |
    > | write(int b)throws IOException                      | 将指定的字节写入此输出流（抽象方法）                         |
    > | write(byte b[])throws IOException                   | 将字节数组中的数据输出到流中                                 |
    > | write(byte b[], int off, int len)throws IOException | 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流 |
    > | flush()throws IOException                           | 刷新此输出流并强制写出所有缓冲的输出字节                     |
    > | close()throws IOException                           | 关闭流                                                       |
    >
    > 编程实例：
    >
    > ```
    > import java.io.IOException;
    > import java.io.InputStream;
    > import java.io.OutputStream;
    > 
    > public class Test {
    > 
    >  /**
    >      * 把输入流中的所有内容赋值到输出流中
    >      * @param in
    >      * @param out
    >      * @throws IOException
    >   */
    >  public void copy(InputStream in, OutputStream out) throws IOException {
    >      byte[] buf = new  byte[4096];
    >      int len = in.read(buf);
    >      //read 是一个字节一个字节地读，字节流的结尾标志是-1
    >      while (len != -1){
    >          out.write(buf, 0, len);
    >          len = in.read(buf);
    >      }
    >  }
    >  public static void main(String[] args) throws IOException {
    >      // TODO Auto-generated method stub
    >      Test t = new Test();
    >      System.out.println("输入字符：");
    >      t.copy(System.in, System.out);
    >  }
    > 
    > }
    > 一般来说，很少直接实现 InputStream 或 OutputStream 上的方法，因为这些方法比较低级，通常会实现它们的子类。
    > ```

  - 字符流

    ```
    字符流以字符为单位，根据码表映射字符，一次可能读多个字节，只能处理字符类型的数据。
    ```

    java.io 包中专门用于字符流处理的类，是以 Reader 和 Writer 为基础派生的一系列类。

    同类 InputStream 和 OutputStream 一样，Reader 和 Writer 也是抽象类，只提供了一系列用于字符流处理的接口。它们的方法与类 InputStream 和 OutputStream 类似，只不过其中的参数换成字符或字符数组。

    Reader 是所有的输入字符流的父类，它是一个抽象类。

    我们先来看一看基类 Reader 的方法，其用法与作用都与 InputStream 和 OutputStream 类似，就不做过多的说明了。

    | 方法                               | 返回值  |
    | ---------------------------------- | ------- |
    | close()                            | void    |
    | mark (int readAheadLimit)          | void    |
    | markSupported()                    | boolean |
    | read()                             | int     |
    | read(char[] cbuf, int off,int len) | int     |
    | ready()                            | boolean |
    | reset()                            | void    |
    | skip(long n)                       | long    |

    Writer 是所有的输出字符流的父类，它是一个抽象类。 Writer 的方法：

    | 方法                                | 返回值 |
    | ----------------------------------- | ------ |
    | close()                             | void   |
    | flush()                             | void   |
    | write(char[] cbuf)                  | void   |
    | write(char[] cbuf, int off,int len) | void   |
    | write(int c)                        | void   |
    | write(String str)                   | void   |
    | write(String str, int off, int len) | void   |

    在这里我们就列举一下有哪些类。

    1. 对字符数组进行处理： CharArrayReader、CharArrayWrite
    2. 对文本文件进行处理：FileReader、FileWriter
    3. 对字符串进行处理：StringReader、StringWriter
    4. 过滤字符流：FilterReader、FileterWriter
    5. 管道字符流：PipedReader、PipedWriter
    6. 行处理字符流：LineNumberReader
    7. 打印字符流：PrintWriter

    类有千万，方法更是不计其数，所以没有必要去掌握所有的方法和类，只需要知道常见常用的就行了，而大多数的类和方法，有一个印象就行，实际开发的时候，查询我们需要的方法就ok。

  - 网络编程

    网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。java.net 包中 J2SE 的 API 包含有类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。

    主要有几方面：

    计算机网络、tcp\udp、httpUrlConnection、InetAddress、Socket、ServerSocket

  - Socket

    网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个 socket。 建立网络通信连接至少要一对端口号(socket)。socket 本质是编程接口(API)，对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口；HTTP 是轿车，提供了封装或者显示数据的具体形式；Socket 是发动机，提供了网络通信的能力。 Socket 的英文原义是“孔”或“插座”。作为 BSD UNIX 的进程通信机制，取后一种意思。通常也称作"套接字"，用于描述 IP 地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。在 Internet 上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个 Socket，并绑定到一个端口上，不同的端口对应于不同的服务。Socket 正如其英文原义那样，像一个多孔插座。一台主机犹如布满各种插座的房间，每个插座有一个编号，有的插座提供 220 伏交流电， 有的提供 110 伏交流电，有的则提供有线电视节目。 客户软件将插头插到不同编号的插座，就可以得到不同的服务。

  - HttpURLConnection

    HttpURLConnection 位于 java.net 包中，支持 HTTP 特定功能。可以使用它来发起网络请求，获取服务器的相关资源。

    > HttpURLConnection 提供了很多方法用于使用 Http，这里只演示了使用 HttpURLConnection 类的基本流程，想要了解更多方法的同学可以查询[API 文档](https://docs.oracle.com/javase/8/docs/api/java/net/HttpURLConnection.html)
    >
    > ```
    > import java.io.BufferedReader;
    > import java.io.IOException;
    > import java.io.InputStream;
    > import java.io.InputStreamReader;
    > import java.net.HttpURLConnection;
    > import java.net.URL;
    > 
    > public class HttpUrlTest {
    >  public static void main(String[] args) {
    >      try {
    >          //设置url
    >          URL shiyanlou = new URL("https://www.shiyanlou.com");
    >          //打开连接
    >          HttpURLConnection urlConnection = (HttpURLConnection)shiyanlou.openConnection();
    >          //设置请求方法
    >          urlConnection.setRequestMethod("GET");
    >          //设置连接超时时间
    >          urlConnection.setConnectTimeout(1000);
    >          //获取输入流
    >          InputStream inputStream = urlConnection.getInputStream();
    >          BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
    >          //打印结果
    >          bufferedReader.lines().forEach(System.out::println);
    >          //关闭连接
    >          inputStream.close();
    >          bufferedReader.close();
    >          urlConnection.disconnect();
    >      } catch (IOException e) {
    >          e.printStackTrace();
    >      }
    >  }
    > }
    > ```

  - InetAddress

    `InetAddress`类用于表示 IP 地址，比如在进行 Socket 编程时，就会使用到该类。

    `InetAddress`没有公共构造方法，我们只能使用它提供的静态方法来构建一个`InetAddress`类实例

    - **getLocalHost()**: 返回本地主机地址
    - **getAllByName（String host）**：从指定的主机名返回 InetAddress 对象的数组，因为主机名可以与多个 IP 地址相关联。
    - **getByAddress（byte [] addr）**：从原始 IP 地址的字节数组中返回一个 InetAddress 对象。
    - **getByName（String host）**：根据提供的主机名创建一个 InetAddress 对象。
    - **getHostAddress（）**：返回文本表示的 IP 地址字符串。
    - **getHostname（）**：获取主机名。

    > ```
    > import java.net.InetAddress;
    > import java.net.UnknownHostException;
    > 
    > public class InetAddressDemo {
    >  public static void main(String[] args) {
    >      try {
    >          InetAddress shiyanlou = InetAddress.getByName("www.shiyanlou.com");
    >          //toString 方法将输出主机名和ip地址
    >          System.out.println(shiyanlou.toString());
    >          //获取ip地址
    >          String ip = shiyanlou.toString().split("/")[1];
    >          //根据IP地址获取主机名
    >          InetAddress byAddress = InetAddress.getByName(ip);
    >          System.out.println("get hostname by IP address:" + byAddress.getHostName());
    >          System.out.println("localhost: "+InetAddress.getLocalHost());
    >      } catch (UnknownHostException e) {
    >          e.printStackTrace();
    >      }
    >  }
    > }
    > ```

  - Socket类使用

    `Socket`类代表一个客户端套接字，可以使用该类向服务器发送和接受数据。一般需要通过下面几个步骤：

    1. 建立与服务器的连接
    2. 使用输出流将数据发送到服务器
    3. 使用输入流读取服务器返回的数据
    4. 关闭连接

    Socket 常用构造方法：

    - `Socket(InetAddress address, int port)`：创建一个套接字，连接到指定 IP 地址和端口的服务器
    - `Socket(String host, int port)`：创建一个套接字，连接到指定的主机名和端口的服务器
    - `Socket(InetAddress address, int port, InetAddress localAddr, int localPort)`：创建一个套接字连接到指定的 IP 地址和端口的服务器，并且显示的指定客户端地址和端口。

    在创建 Socket 时，需要捕获异常。

  - ServerSocket类

    `ServerSocket`类用于实现服务器套接字，服务器套接字会等待客户端网络连接，与客户端连接之后，会进行一系列操作，然后将结果返回给客户端。

    创建一个`ServerSocket`一般需要以下几个步骤：

    1. 创建服务器套接字并将其绑定到特定的接口

    2. 等待客户端连接

    3. 通过客户端套接字获取输入流，从客户端读取数据

    4. 通过客户端套接字获取输出流，发送数据到客户端

    5. 关闭套接字

       > ServerSocket serverSocket = new ServerSocket(8888);   

  - socket实例

    java.net 包提供了两个类`Socket`和`ServerSocket`，分别实现 Socket 连接的客户端和服务器端。

    > package com.ws.socket;
    >
    > import java.io.BufferedReader;
    > import java.io.IOException;
    > import java.io.InputStreamReader;
    > import java.io.PrintWriter;
    > import java.net.Socket;
    > import java.util.Scanner;
    >
    > public class EchoClient {
    >  public static void main(String[] args) {
    >      String hostname = "127.0.0.1";
    >      //socket端口
    >      int port = 1080;
    >      Scanner userIn = new Scanner(System.in);
    >      try {
    >          //建立socket连接
    >          Socket socket = new Socket(hostname, port);
    >          //获取socket输出流
    >          PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
    >          //获取输入流
    >          BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
    >          String userInput;
    >          System.out.println("请输入信息：");
    >          //当用户输入exit时退出
    >          while (!"exit".equals(userInput = userIn.nextLine())) {
    >              out.println(userInput);
    >              System.out.println("收到服务端回应:" + in.readLine());
    >          }
    >          //关闭socket
    >          socket.close();
    >      } catch (IOException e) {
    >          e.printStackTrace();
    >      }
    >  }
    > }

    server:

    > ```
    > package com.ws.socket;
    > 
    > import java.io.BufferedReader;
    > import java.io.IOException;
    > import java.io.InputStreamReader;
    > import java.io.PrintWriter;
    > import java.net.ServerSocket;
    > import java.net.Socket;
    > 
    > public class EchoServer {
    >  public static void main(String[] args) {
    >      try {
    >          //服务端需要使用ServerSocket类
    >          ServerSocket serverSocket = new ServerSocket(1080);
    >          //阻塞 等待客户端连接
    >          Socket client = serverSocket.accept();
    >          PrintWriter out = new PrintWriter(client.getOutputStream(), true);
    >          BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));
    >          String userIn;
    >          while ((userIn = in.readLine()) != null) {
    >              System.out.println("收到客户端消息：" + userIn);
    >              //发回客户端
    >              out.println(userIn);
    >          }
    >      } catch (IOException e) {
    >          e.printStackTrace();
    >      }
    >  }
    > }
    > ```
    >
    > 可以尝试多线程、同时多个client。

- network

  - TCP

    TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。在简化的计算机网络 OSI 模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内另一个重要的传输协议。在因特网协议族（Internet protocol suite）中，TCP 层是位于 IP 层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是 IP 层不提供这样的流机制，而是提供不可靠的包交换。
    应用层向 TCP 层发送用于网间传输的、用 8 位字节表示的数据流，然后 TCP 把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后 TCP 把结果包传给 IP 层，由它来通过网络将包传送给接收端实体的 TCP 层。TCP 为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP 用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。

  - UDP

    UDP 是 User Datagram Protocol 的简称， 中文名是用户数据报协议，是 OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768 是 UDP 的正式规范。UDP 在 IP 报文的协议号是 17。
    UDP 协议全称是用户数据报协议，在网络中它与 TCP 协议一样用于处理数据包，是一种无连接的协议。在 OSI 模型中，在第四层——传输层，处于 IP 协议的上一层。UDP 有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。UDP 用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用 UDP 协议。UDP 协议从问世至今已经被使用了很多年，虽然其最初的光彩已经被一些类似协议所掩盖，但是即使是在今天 UDP 仍然不失为一项非常实用和可行的网络传输层协议。
    与所熟知的 TCP（传输控制协议）协议一样，UDP 协议直接位于 IP（网际协议）协议的顶层。根据 OSI（开放系统互连）参考模型，UDP 和 TCP 都属于传输层协议。UDP 协议的主要作用是将网络数据流量压缩成数据包的形式。一个典型的数据包就是一个二进制数据的传输单位。每一个数据包的前 8 个字节用来包含报头信息，剩余字节则用来包含具体的传输数据。

2.学习心得   

- 实践出真知、不手动操作几次是难以掌握
- 断章取义难理解
- 心急吃不得热豆腐
- 总结归纳很重要
- 工欲善其事、必先利其器
- 计划赶不上没变化
- 明白原理很重要



## 明日学习计划

------

- linux学习

  软件安装、数据提取、日志

- java

  多线程、JDBC、反射、正则表达式、设计模式

- GO

  面向对象、协程、通道、实践

## 截图

| [ ..](https://github.com/inspurcloudgroup/icprd1/tree/master/吴帅/learn_pic) |                                                              |                                                              |               |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------- |
|                                                              | [java01.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/java01.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/8609a39ea6b6eec4e5caac20bdac32cbab23a370) | 4 hours ago   |
|                                                              | [java02.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/java02.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/8609a39ea6b6eec4e5caac20bdac32cbab23a370) | 4 hours ago   |
|                                                              | [java03.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/java03.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/8609a39ea6b6eec4e5caac20bdac32cbab23a370) | 4 hours ago   |
|                                                              | [java04.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/java04.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/8609a39ea6b6eec4e5caac20bdac32cbab23a370) | 4 hours ago   |
|                                                              | [java05.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/java05.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/8609a39ea6b6eec4e5caac20bdac32cbab23a370) | 4 hours ago   |
|                                                              | [java06.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/java06.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/8609a39ea6b6eec4e5caac20bdac32cbab23a370) | 4 hours ago   |
|                                                              | [java07.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/java07.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/8609a39ea6b6eec4e5caac20bdac32cbab23a370) | 4 hours ago   |
|                                                              | [java08.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/java08.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/8609a39ea6b6eec4e5caac20bdac32cbab23a370) | 4 hours ago   |
|                                                              | [java09.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/java09.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/8609a39ea6b6eec4e5caac20bdac32cbab23a370) | 4 hours ago   |
|                                                              | [java10.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/java10.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/8609a39ea6b6eec4e5caac20bdac32cbab23a370) | 4 hours ago   |
|                                                              | [java11.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/java11.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/8609a39ea6b6eec4e5caac20bdac32cbab23a370) | 4 hours ago   |
|                                                              | [java12.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/java12.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/8609a39ea6b6eec4e5caac20bdac32cbab23a370) | 4 hours ago   |
|                                                              | [java13.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/java13.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/8609a39ea6b6eec4e5caac20bdac32cbab23a370) | 4 hours ago   |
|                                                              | [java14.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/java14.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/8609a39ea6b6eec4e5caac20bdac32cbab23a370) | 4 hours ago   |
|                                                              | [java15.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/java15.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/8609a39ea6b6eec4e5caac20bdac32cbab23a370) | 4 hours ago   |
|                                                              | [os01.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/os01.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/79edd16d694729735df65e0427ec4c6bc3528772) | 7 minutes ago |
|                                                              | [os02.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/os02.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/79edd16d694729735df65e0427ec4c6bc3528772) | 7 minutes ago |
|                                                              | [os03.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/os03.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/79edd16d694729735df65e0427ec4c6bc3528772) | 7 minutes ago |
|                                                              | [os04.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/os04.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/79edd16d694729735df65e0427ec4c6bc3528772) | 7 minutes ago |
|                                                              | [os05.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/os05.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/79edd16d694729735df65e0427ec4c6bc3528772) | 7 minutes ago |
|                                                              | [os06.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/os06.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/79edd16d694729735df65e0427ec4c6bc3528772) | 7 minutes ago |
|                                                              | [readme.md](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/readme.md) | [Create readme.md](https://github.com/inspurcloudgroup/icprd1/commit/d383c0bd1c2e6eb619ee643ea6262caa480fd2e6) | 4 hours ago   |
|                                                              | [socket01.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/socket01.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/8609a39ea6b6eec4e5caac20bdac32cbab23a370) | 4 hours ago   |
|                                                              | [socket02.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/socket02.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/8609a39ea6b6eec4e5caac20bdac32cbab23a370) | 4 hours ago   |
|                                                              | [socket03.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/socket03.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/8609a39ea6b6eec4e5caac20bdac32cbab23a370) | 4 hours ago   |
|                                                              | [socket04.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/socket04.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/8609a39ea6b6eec4e5caac20bdac32cbab23a370) | 4 hours ago   |
|                                                              | [socket05.png](https://github.com/inspurcloudgroup/icprd1/blob/master/吴帅/learn_pic/0607/socket05.png) | [Add files via upload](https://github.com/inspurcloudgroup/icprd1/commit/8609a39ea6b6eec4e5caac20bdac32cbab23a370) | 4 hours ago   |











